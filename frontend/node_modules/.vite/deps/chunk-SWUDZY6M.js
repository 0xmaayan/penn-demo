import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-HM4MQYWN.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_5, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/.pnpm/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i48, r23 = new Float64Array(16);
        if (init)
          for (i48 = 0; i48 < init.length; i48++)
            r23[i48] = init[i48];
        return r23;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D8 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X4 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y3 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I5 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x8, i48, h14, l12) {
        x8[i48] = h14 >> 24 & 255;
        x8[i48 + 1] = h14 >> 16 & 255;
        x8[i48 + 2] = h14 >> 8 & 255;
        x8[i48 + 3] = h14 & 255;
        x8[i48 + 4] = l12 >> 24 & 255;
        x8[i48 + 5] = l12 >> 16 & 255;
        x8[i48 + 6] = l12 >> 8 & 255;
        x8[i48 + 7] = l12 & 255;
      }
      function vn(x8, xi, y10, yi, n24) {
        var i48, d9 = 0;
        for (i48 = 0; i48 < n24; i48++)
          d9 |= x8[xi + i48] ^ y10[yi + i48];
        return (1 & d9 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x8, xi, y10, yi) {
        return vn(x8, xi, y10, yi, 16);
      }
      function crypto_verify_32(x8, xi, y10, yi) {
        return vn(x8, xi, y10, yi, 32);
      }
      function core_salsa20(o13, p12, k3, c14) {
        var j0 = c14[0] & 255 | (c14[1] & 255) << 8 | (c14[2] & 255) << 16 | (c14[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j32 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c14[4] & 255 | (c14[5] & 255) << 8 | (c14[6] & 255) << 16 | (c14[7] & 255) << 24, j6 = p12[0] & 255 | (p12[1] & 255) << 8 | (p12[2] & 255) << 16 | (p12[3] & 255) << 24, j7 = p12[4] & 255 | (p12[5] & 255) << 8 | (p12[6] & 255) << 16 | (p12[7] & 255) << 24, j8 = p12[8] & 255 | (p12[9] & 255) << 8 | (p12[10] & 255) << 16 | (p12[11] & 255) << 24, j9 = p12[12] & 255 | (p12[13] & 255) << 8 | (p12[14] & 255) << 16 | (p12[15] & 255) << 24, j10 = c14[8] & 255 | (c14[9] & 255) << 8 | (c14[10] & 255) << 16 | (c14[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c14[12] & 255 | (c14[13] & 255) << 8 | (c14[14] & 255) << 16 | (c14[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j32, x42 = j4, x52 = j5, x62 = j6, x72 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u10;
        for (var i48 = 0; i48 < 20; i48 += 2) {
          u10 = x0 + x12 | 0;
          x42 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x42 + x0 | 0;
          x8 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x8 + x42 | 0;
          x12 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x12 + x8 | 0;
          x0 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x52 + x1 | 0;
          x9 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x9 + x52 | 0;
          x13 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x13 + x9 | 0;
          x1 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x1 + x13 | 0;
          x52 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x10 + x62 | 0;
          x14 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x14 + x10 | 0;
          x22 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x22 + x14 | 0;
          x62 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x62 + x22 | 0;
          x10 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x15 + x11 | 0;
          x32 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x32 + x15 | 0;
          x72 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x72 + x32 | 0;
          x11 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x11 + x72 | 0;
          x15 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x0 + x32 | 0;
          x1 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x1 + x0 | 0;
          x22 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x22 + x1 | 0;
          x32 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x32 + x22 | 0;
          x0 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x52 + x42 | 0;
          x62 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x62 + x52 | 0;
          x72 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x72 + x62 | 0;
          x42 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x42 + x72 | 0;
          x52 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x10 + x9 | 0;
          x11 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x11 + x10 | 0;
          x8 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x8 + x11 | 0;
          x9 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x9 + x8 | 0;
          x10 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x15 + x14 | 0;
          x12 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x12 + x15 | 0;
          x13 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x13 + x12 | 0;
          x14 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x14 + x13 | 0;
          x15 ^= u10 << 18 | u10 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j22 | 0;
        x32 = x32 + j32 | 0;
        x42 = x42 + j4 | 0;
        x52 = x52 + j5 | 0;
        x62 = x62 + j6 | 0;
        x72 = x72 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o13[0] = x0 >>> 0 & 255;
        o13[1] = x0 >>> 8 & 255;
        o13[2] = x0 >>> 16 & 255;
        o13[3] = x0 >>> 24 & 255;
        o13[4] = x1 >>> 0 & 255;
        o13[5] = x1 >>> 8 & 255;
        o13[6] = x1 >>> 16 & 255;
        o13[7] = x1 >>> 24 & 255;
        o13[8] = x22 >>> 0 & 255;
        o13[9] = x22 >>> 8 & 255;
        o13[10] = x22 >>> 16 & 255;
        o13[11] = x22 >>> 24 & 255;
        o13[12] = x32 >>> 0 & 255;
        o13[13] = x32 >>> 8 & 255;
        o13[14] = x32 >>> 16 & 255;
        o13[15] = x32 >>> 24 & 255;
        o13[16] = x42 >>> 0 & 255;
        o13[17] = x42 >>> 8 & 255;
        o13[18] = x42 >>> 16 & 255;
        o13[19] = x42 >>> 24 & 255;
        o13[20] = x52 >>> 0 & 255;
        o13[21] = x52 >>> 8 & 255;
        o13[22] = x52 >>> 16 & 255;
        o13[23] = x52 >>> 24 & 255;
        o13[24] = x62 >>> 0 & 255;
        o13[25] = x62 >>> 8 & 255;
        o13[26] = x62 >>> 16 & 255;
        o13[27] = x62 >>> 24 & 255;
        o13[28] = x72 >>> 0 & 255;
        o13[29] = x72 >>> 8 & 255;
        o13[30] = x72 >>> 16 & 255;
        o13[31] = x72 >>> 24 & 255;
        o13[32] = x8 >>> 0 & 255;
        o13[33] = x8 >>> 8 & 255;
        o13[34] = x8 >>> 16 & 255;
        o13[35] = x8 >>> 24 & 255;
        o13[36] = x9 >>> 0 & 255;
        o13[37] = x9 >>> 8 & 255;
        o13[38] = x9 >>> 16 & 255;
        o13[39] = x9 >>> 24 & 255;
        o13[40] = x10 >>> 0 & 255;
        o13[41] = x10 >>> 8 & 255;
        o13[42] = x10 >>> 16 & 255;
        o13[43] = x10 >>> 24 & 255;
        o13[44] = x11 >>> 0 & 255;
        o13[45] = x11 >>> 8 & 255;
        o13[46] = x11 >>> 16 & 255;
        o13[47] = x11 >>> 24 & 255;
        o13[48] = x12 >>> 0 & 255;
        o13[49] = x12 >>> 8 & 255;
        o13[50] = x12 >>> 16 & 255;
        o13[51] = x12 >>> 24 & 255;
        o13[52] = x13 >>> 0 & 255;
        o13[53] = x13 >>> 8 & 255;
        o13[54] = x13 >>> 16 & 255;
        o13[55] = x13 >>> 24 & 255;
        o13[56] = x14 >>> 0 & 255;
        o13[57] = x14 >>> 8 & 255;
        o13[58] = x14 >>> 16 & 255;
        o13[59] = x14 >>> 24 & 255;
        o13[60] = x15 >>> 0 & 255;
        o13[61] = x15 >>> 8 & 255;
        o13[62] = x15 >>> 16 & 255;
        o13[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o13, p12, k3, c14) {
        var j0 = c14[0] & 255 | (c14[1] & 255) << 8 | (c14[2] & 255) << 16 | (c14[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j32 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c14[4] & 255 | (c14[5] & 255) << 8 | (c14[6] & 255) << 16 | (c14[7] & 255) << 24, j6 = p12[0] & 255 | (p12[1] & 255) << 8 | (p12[2] & 255) << 16 | (p12[3] & 255) << 24, j7 = p12[4] & 255 | (p12[5] & 255) << 8 | (p12[6] & 255) << 16 | (p12[7] & 255) << 24, j8 = p12[8] & 255 | (p12[9] & 255) << 8 | (p12[10] & 255) << 16 | (p12[11] & 255) << 24, j9 = p12[12] & 255 | (p12[13] & 255) << 8 | (p12[14] & 255) << 16 | (p12[15] & 255) << 24, j10 = c14[8] & 255 | (c14[9] & 255) << 8 | (c14[10] & 255) << 16 | (c14[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c14[12] & 255 | (c14[13] & 255) << 8 | (c14[14] & 255) << 16 | (c14[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j32, x42 = j4, x52 = j5, x62 = j6, x72 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u10;
        for (var i48 = 0; i48 < 20; i48 += 2) {
          u10 = x0 + x12 | 0;
          x42 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x42 + x0 | 0;
          x8 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x8 + x42 | 0;
          x12 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x12 + x8 | 0;
          x0 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x52 + x1 | 0;
          x9 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x9 + x52 | 0;
          x13 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x13 + x9 | 0;
          x1 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x1 + x13 | 0;
          x52 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x10 + x62 | 0;
          x14 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x14 + x10 | 0;
          x22 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x22 + x14 | 0;
          x62 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x62 + x22 | 0;
          x10 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x15 + x11 | 0;
          x32 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x32 + x15 | 0;
          x72 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x72 + x32 | 0;
          x11 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x11 + x72 | 0;
          x15 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x0 + x32 | 0;
          x1 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x1 + x0 | 0;
          x22 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x22 + x1 | 0;
          x32 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x32 + x22 | 0;
          x0 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x52 + x42 | 0;
          x62 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x62 + x52 | 0;
          x72 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x72 + x62 | 0;
          x42 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x42 + x72 | 0;
          x52 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x10 + x9 | 0;
          x11 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x11 + x10 | 0;
          x8 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x8 + x11 | 0;
          x9 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x9 + x8 | 0;
          x10 ^= u10 << 18 | u10 >>> 32 - 18;
          u10 = x15 + x14 | 0;
          x12 ^= u10 << 7 | u10 >>> 32 - 7;
          u10 = x12 + x15 | 0;
          x13 ^= u10 << 9 | u10 >>> 32 - 9;
          u10 = x13 + x12 | 0;
          x14 ^= u10 << 13 | u10 >>> 32 - 13;
          u10 = x14 + x13 | 0;
          x15 ^= u10 << 18 | u10 >>> 32 - 18;
        }
        o13[0] = x0 >>> 0 & 255;
        o13[1] = x0 >>> 8 & 255;
        o13[2] = x0 >>> 16 & 255;
        o13[3] = x0 >>> 24 & 255;
        o13[4] = x52 >>> 0 & 255;
        o13[5] = x52 >>> 8 & 255;
        o13[6] = x52 >>> 16 & 255;
        o13[7] = x52 >>> 24 & 255;
        o13[8] = x10 >>> 0 & 255;
        o13[9] = x10 >>> 8 & 255;
        o13[10] = x10 >>> 16 & 255;
        o13[11] = x10 >>> 24 & 255;
        o13[12] = x15 >>> 0 & 255;
        o13[13] = x15 >>> 8 & 255;
        o13[14] = x15 >>> 16 & 255;
        o13[15] = x15 >>> 24 & 255;
        o13[16] = x62 >>> 0 & 255;
        o13[17] = x62 >>> 8 & 255;
        o13[18] = x62 >>> 16 & 255;
        o13[19] = x62 >>> 24 & 255;
        o13[20] = x72 >>> 0 & 255;
        o13[21] = x72 >>> 8 & 255;
        o13[22] = x72 >>> 16 & 255;
        o13[23] = x72 >>> 24 & 255;
        o13[24] = x8 >>> 0 & 255;
        o13[25] = x8 >>> 8 & 255;
        o13[26] = x8 >>> 16 & 255;
        o13[27] = x8 >>> 24 & 255;
        o13[28] = x9 >>> 0 & 255;
        o13[29] = x9 >>> 8 & 255;
        o13[30] = x9 >>> 16 & 255;
        o13[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k3, c14) {
        core_salsa20(out, inp, k3, c14);
      }
      function crypto_core_hsalsa20(out, inp, k3, c14) {
        core_hsalsa20(out, inp, k3, c14);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c14, cpos, m12, mpos, b9, n24, k3) {
        var z4 = new Uint8Array(16), x8 = new Uint8Array(64);
        var u10, i48;
        for (i48 = 0; i48 < 16; i48++)
          z4[i48] = 0;
        for (i48 = 0; i48 < 8; i48++)
          z4[i48] = n24[i48];
        while (b9 >= 64) {
          crypto_core_salsa20(x8, z4, k3, sigma);
          for (i48 = 0; i48 < 64; i48++)
            c14[cpos + i48] = m12[mpos + i48] ^ x8[i48];
          u10 = 1;
          for (i48 = 8; i48 < 16; i48++) {
            u10 = u10 + (z4[i48] & 255) | 0;
            z4[i48] = u10 & 255;
            u10 >>>= 8;
          }
          b9 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b9 > 0) {
          crypto_core_salsa20(x8, z4, k3, sigma);
          for (i48 = 0; i48 < b9; i48++)
            c14[cpos + i48] = m12[mpos + i48] ^ x8[i48];
        }
        return 0;
      }
      function crypto_stream_salsa20(c14, cpos, b9, n24, k3) {
        var z4 = new Uint8Array(16), x8 = new Uint8Array(64);
        var u10, i48;
        for (i48 = 0; i48 < 16; i48++)
          z4[i48] = 0;
        for (i48 = 0; i48 < 8; i48++)
          z4[i48] = n24[i48];
        while (b9 >= 64) {
          crypto_core_salsa20(x8, z4, k3, sigma);
          for (i48 = 0; i48 < 64; i48++)
            c14[cpos + i48] = x8[i48];
          u10 = 1;
          for (i48 = 8; i48 < 16; i48++) {
            u10 = u10 + (z4[i48] & 255) | 0;
            z4[i48] = u10 & 255;
            u10 >>>= 8;
          }
          b9 -= 64;
          cpos += 64;
        }
        if (b9 > 0) {
          crypto_core_salsa20(x8, z4, k3, sigma);
          for (i48 = 0; i48 < b9; i48++)
            c14[cpos + i48] = x8[i48];
        }
        return 0;
      }
      function crypto_stream(c14, cpos, d9, n24, k3) {
        var s12 = new Uint8Array(32);
        crypto_core_hsalsa20(s12, n24, k3, sigma);
        var sn2 = new Uint8Array(8);
        for (var i48 = 0; i48 < 8; i48++)
          sn2[i48] = n24[i48 + 16];
        return crypto_stream_salsa20(c14, cpos, d9, sn2, s12);
      }
      function crypto_stream_xor(c14, cpos, m12, mpos, d9, n24, k3) {
        var s12 = new Uint8Array(32);
        crypto_core_hsalsa20(s12, n24, k3, sigma);
        var sn2 = new Uint8Array(8);
        for (var i48 = 0; i48 < 8; i48++)
          sn2[i48] = n24[i48 + 16];
        return crypto_stream_salsa20_xor(c14, cpos, m12, mpos, d9, sn2, s12);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t22, t32, t42, t52, t62, t72;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t22 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
        t32 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t22 >>> 7 | t32 << 9) & 8191;
        t42 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t32 >>> 4 | t42 << 12) & 255;
        this.r[5] = t42 >>> 1 & 8190;
        t52 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t42 >>> 14 | t52 << 2) & 8191;
        t62 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t52 >>> 11 | t62 << 5) & 8065;
        t72 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t62 >>> 8 | t72 << 8) & 8191;
        this.r[9] = t72 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m12, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t22, t32, t42, t52, t62, t72, c14;
        var d0, d1, d22, d32, d42, d52, d62, d72, d82, d9;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h52 = this.h[5], h62 = this.h[6], h72 = this.h[7], h82 = this.h[8], h92 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r23 = this.r[2], r32 = this.r[3], r42 = this.r[4], r52 = this.r[5], r62 = this.r[6], r72 = this.r[7], r82 = this.r[8], r92 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m12[mpos + 0] & 255 | (m12[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m12[mpos + 2] & 255 | (m12[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t22 = m12[mpos + 4] & 255 | (m12[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t22 << 6) & 8191;
          t32 = m12[mpos + 6] & 255 | (m12[mpos + 7] & 255) << 8;
          h32 += (t22 >>> 7 | t32 << 9) & 8191;
          t42 = m12[mpos + 8] & 255 | (m12[mpos + 9] & 255) << 8;
          h42 += (t32 >>> 4 | t42 << 12) & 8191;
          h52 += t42 >>> 1 & 8191;
          t52 = m12[mpos + 10] & 255 | (m12[mpos + 11] & 255) << 8;
          h62 += (t42 >>> 14 | t52 << 2) & 8191;
          t62 = m12[mpos + 12] & 255 | (m12[mpos + 13] & 255) << 8;
          h72 += (t52 >>> 11 | t62 << 5) & 8191;
          t72 = m12[mpos + 14] & 255 | (m12[mpos + 15] & 255) << 8;
          h82 += (t62 >>> 8 | t72 << 8) & 8191;
          h92 += t72 >>> 5 | hibit;
          c14 = 0;
          d0 = c14;
          d0 += h0 * r0;
          d0 += h1 * (5 * r92);
          d0 += h22 * (5 * r82);
          d0 += h32 * (5 * r72);
          d0 += h42 * (5 * r62);
          c14 = d0 >>> 13;
          d0 &= 8191;
          d0 += h52 * (5 * r52);
          d0 += h62 * (5 * r42);
          d0 += h72 * (5 * r32);
          d0 += h82 * (5 * r23);
          d0 += h92 * (5 * r1);
          c14 += d0 >>> 13;
          d0 &= 8191;
          d1 = c14;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r92);
          d1 += h32 * (5 * r82);
          d1 += h42 * (5 * r72);
          c14 = d1 >>> 13;
          d1 &= 8191;
          d1 += h52 * (5 * r62);
          d1 += h62 * (5 * r52);
          d1 += h72 * (5 * r42);
          d1 += h82 * (5 * r32);
          d1 += h92 * (5 * r23);
          c14 += d1 >>> 13;
          d1 &= 8191;
          d22 = c14;
          d22 += h0 * r23;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r92);
          d22 += h42 * (5 * r82);
          c14 = d22 >>> 13;
          d22 &= 8191;
          d22 += h52 * (5 * r72);
          d22 += h62 * (5 * r62);
          d22 += h72 * (5 * r52);
          d22 += h82 * (5 * r42);
          d22 += h92 * (5 * r32);
          c14 += d22 >>> 13;
          d22 &= 8191;
          d32 = c14;
          d32 += h0 * r32;
          d32 += h1 * r23;
          d32 += h22 * r1;
          d32 += h32 * r0;
          d32 += h42 * (5 * r92);
          c14 = d32 >>> 13;
          d32 &= 8191;
          d32 += h52 * (5 * r82);
          d32 += h62 * (5 * r72);
          d32 += h72 * (5 * r62);
          d32 += h82 * (5 * r52);
          d32 += h92 * (5 * r42);
          c14 += d32 >>> 13;
          d32 &= 8191;
          d42 = c14;
          d42 += h0 * r42;
          d42 += h1 * r32;
          d42 += h22 * r23;
          d42 += h32 * r1;
          d42 += h42 * r0;
          c14 = d42 >>> 13;
          d42 &= 8191;
          d42 += h52 * (5 * r92);
          d42 += h62 * (5 * r82);
          d42 += h72 * (5 * r72);
          d42 += h82 * (5 * r62);
          d42 += h92 * (5 * r52);
          c14 += d42 >>> 13;
          d42 &= 8191;
          d52 = c14;
          d52 += h0 * r52;
          d52 += h1 * r42;
          d52 += h22 * r32;
          d52 += h32 * r23;
          d52 += h42 * r1;
          c14 = d52 >>> 13;
          d52 &= 8191;
          d52 += h52 * r0;
          d52 += h62 * (5 * r92);
          d52 += h72 * (5 * r82);
          d52 += h82 * (5 * r72);
          d52 += h92 * (5 * r62);
          c14 += d52 >>> 13;
          d52 &= 8191;
          d62 = c14;
          d62 += h0 * r62;
          d62 += h1 * r52;
          d62 += h22 * r42;
          d62 += h32 * r32;
          d62 += h42 * r23;
          c14 = d62 >>> 13;
          d62 &= 8191;
          d62 += h52 * r1;
          d62 += h62 * r0;
          d62 += h72 * (5 * r92);
          d62 += h82 * (5 * r82);
          d62 += h92 * (5 * r72);
          c14 += d62 >>> 13;
          d62 &= 8191;
          d72 = c14;
          d72 += h0 * r72;
          d72 += h1 * r62;
          d72 += h22 * r52;
          d72 += h32 * r42;
          d72 += h42 * r32;
          c14 = d72 >>> 13;
          d72 &= 8191;
          d72 += h52 * r23;
          d72 += h62 * r1;
          d72 += h72 * r0;
          d72 += h82 * (5 * r92);
          d72 += h92 * (5 * r82);
          c14 += d72 >>> 13;
          d72 &= 8191;
          d82 = c14;
          d82 += h0 * r82;
          d82 += h1 * r72;
          d82 += h22 * r62;
          d82 += h32 * r52;
          d82 += h42 * r42;
          c14 = d82 >>> 13;
          d82 &= 8191;
          d82 += h52 * r32;
          d82 += h62 * r23;
          d82 += h72 * r1;
          d82 += h82 * r0;
          d82 += h92 * (5 * r92);
          c14 += d82 >>> 13;
          d82 &= 8191;
          d9 = c14;
          d9 += h0 * r92;
          d9 += h1 * r82;
          d9 += h22 * r72;
          d9 += h32 * r62;
          d9 += h42 * r52;
          c14 = d9 >>> 13;
          d9 &= 8191;
          d9 += h52 * r42;
          d9 += h62 * r32;
          d9 += h72 * r23;
          d9 += h82 * r1;
          d9 += h92 * r0;
          c14 += d9 >>> 13;
          d9 &= 8191;
          c14 = (c14 << 2) + c14 | 0;
          c14 = c14 + d0 | 0;
          d0 = c14 & 8191;
          c14 = c14 >>> 13;
          d1 += c14;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d32;
          h42 = d42;
          h52 = d52;
          h62 = d62;
          h72 = d72;
          h82 = d82;
          h92 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h32;
        this.h[4] = h42;
        this.h[5] = h52;
        this.h[6] = h62;
        this.h[7] = h72;
        this.h[8] = h82;
        this.h[9] = h92;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g9 = new Uint16Array(10);
        var c14, mask, f13, i48;
        if (this.leftover) {
          i48 = this.leftover;
          this.buffer[i48++] = 1;
          for (; i48 < 16; i48++)
            this.buffer[i48] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c14 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i48 = 2; i48 < 10; i48++) {
          this.h[i48] += c14;
          c14 = this.h[i48] >>> 13;
          this.h[i48] &= 8191;
        }
        this.h[0] += c14 * 5;
        c14 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c14;
        c14 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c14;
        g9[0] = this.h[0] + 5;
        c14 = g9[0] >>> 13;
        g9[0] &= 8191;
        for (i48 = 1; i48 < 10; i48++) {
          g9[i48] = this.h[i48] + c14;
          c14 = g9[i48] >>> 13;
          g9[i48] &= 8191;
        }
        g9[9] -= 1 << 13;
        mask = (c14 ^ 1) - 1;
        for (i48 = 0; i48 < 10; i48++)
          g9[i48] &= mask;
        mask = ~mask;
        for (i48 = 0; i48 < 10; i48++)
          this.h[i48] = this.h[i48] & mask | g9[i48];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f13 = this.h[0] + this.pad[0];
        this.h[0] = f13 & 65535;
        for (i48 = 1; i48 < 8; i48++) {
          f13 = (this.h[i48] + this.pad[i48] | 0) + (f13 >>> 16) | 0;
          this.h[i48] = f13 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m12, mpos, bytes2) {
        var i48, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i48 = 0; i48 < want; i48++)
            this.buffer[this.leftover + i48] = m12[mpos + i48];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m12, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i48 = 0; i48 < bytes2; i48++)
            this.buffer[this.leftover + i48] = m12[mpos + i48];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m12, mpos, n24, k3) {
        var s12 = new poly1305(k3);
        s12.update(m12, mpos, n24);
        s12.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h14, hpos, m12, mpos, n24, k3) {
        var x8 = new Uint8Array(16);
        crypto_onetimeauth(x8, 0, m12, mpos, n24, k3);
        return crypto_verify_16(h14, hpos, x8, 0);
      }
      function crypto_secretbox(c14, m12, d9, n24, k3) {
        var i48;
        if (d9 < 32)
          return -1;
        crypto_stream_xor(c14, 0, m12, 0, d9, n24, k3);
        crypto_onetimeauth(c14, 16, c14, 32, d9 - 32, c14);
        for (i48 = 0; i48 < 16; i48++)
          c14[i48] = 0;
        return 0;
      }
      function crypto_secretbox_open(m12, c14, d9, n24, k3) {
        var i48;
        var x8 = new Uint8Array(32);
        if (d9 < 32)
          return -1;
        crypto_stream(x8, 0, 32, n24, k3);
        if (crypto_onetimeauth_verify(c14, 16, c14, 32, d9 - 32, x8) !== 0)
          return -1;
        crypto_stream_xor(m12, 0, c14, 0, d9, n24, k3);
        for (i48 = 0; i48 < 32; i48++)
          m12[i48] = 0;
        return 0;
      }
      function set25519(r23, a13) {
        var i48;
        for (i48 = 0; i48 < 16; i48++)
          r23[i48] = a13[i48] | 0;
      }
      function car25519(o13) {
        var i48, v9, c14 = 1;
        for (i48 = 0; i48 < 16; i48++) {
          v9 = o13[i48] + c14 + 65535;
          c14 = Math.floor(v9 / 65536);
          o13[i48] = v9 - c14 * 65536;
        }
        o13[0] += c14 - 1 + 37 * (c14 - 1);
      }
      function sel25519(p12, q4, b9) {
        var t13, c14 = ~(b9 - 1);
        for (var i48 = 0; i48 < 16; i48++) {
          t13 = c14 & (p12[i48] ^ q4[i48]);
          p12[i48] ^= t13;
          q4[i48] ^= t13;
        }
      }
      function pack25519(o13, n24) {
        var i48, j4, b9;
        var m12 = gf(), t13 = gf();
        for (i48 = 0; i48 < 16; i48++)
          t13[i48] = n24[i48];
        car25519(t13);
        car25519(t13);
        car25519(t13);
        for (j4 = 0; j4 < 2; j4++) {
          m12[0] = t13[0] - 65517;
          for (i48 = 1; i48 < 15; i48++) {
            m12[i48] = t13[i48] - 65535 - (m12[i48 - 1] >> 16 & 1);
            m12[i48 - 1] &= 65535;
          }
          m12[15] = t13[15] - 32767 - (m12[14] >> 16 & 1);
          b9 = m12[15] >> 16 & 1;
          m12[14] &= 65535;
          sel25519(t13, m12, 1 - b9);
        }
        for (i48 = 0; i48 < 16; i48++) {
          o13[2 * i48] = t13[i48] & 255;
          o13[2 * i48 + 1] = t13[i48] >> 8;
        }
      }
      function neq25519(a13, b9) {
        var c14 = new Uint8Array(32), d9 = new Uint8Array(32);
        pack25519(c14, a13);
        pack25519(d9, b9);
        return crypto_verify_32(c14, 0, d9, 0);
      }
      function par25519(a13) {
        var d9 = new Uint8Array(32);
        pack25519(d9, a13);
        return d9[0] & 1;
      }
      function unpack25519(o13, n24) {
        var i48;
        for (i48 = 0; i48 < 16; i48++)
          o13[i48] = n24[2 * i48] + (n24[2 * i48 + 1] << 8);
        o13[15] &= 32767;
      }
      function A13(o13, a13, b9) {
        for (var i48 = 0; i48 < 16; i48++)
          o13[i48] = a13[i48] + b9[i48];
      }
      function Z5(o13, a13, b9) {
        for (var i48 = 0; i48 < 16; i48++)
          o13[i48] = a13[i48] - b9[i48];
      }
      function M6(o13, a13, b9) {
        var v9, c14, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t82 = 0, t92 = 0, t102 = 0, t112 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b9[0], b1 = b9[1], b22 = b9[2], b32 = b9[3], b42 = b9[4], b52 = b9[5], b62 = b9[6], b72 = b9[7], b82 = b9[8], b92 = b9[9], b10 = b9[10], b11 = b9[11], b12 = b9[12], b13 = b9[13], b14 = b9[14], b15 = b9[15];
        v9 = a13[0];
        t0 += v9 * b0;
        t1 += v9 * b1;
        t22 += v9 * b22;
        t32 += v9 * b32;
        t42 += v9 * b42;
        t52 += v9 * b52;
        t62 += v9 * b62;
        t72 += v9 * b72;
        t82 += v9 * b82;
        t92 += v9 * b92;
        t102 += v9 * b10;
        t112 += v9 * b11;
        t122 += v9 * b12;
        t13 += v9 * b13;
        t14 += v9 * b14;
        t15 += v9 * b15;
        v9 = a13[1];
        t1 += v9 * b0;
        t22 += v9 * b1;
        t32 += v9 * b22;
        t42 += v9 * b32;
        t52 += v9 * b42;
        t62 += v9 * b52;
        t72 += v9 * b62;
        t82 += v9 * b72;
        t92 += v9 * b82;
        t102 += v9 * b92;
        t112 += v9 * b10;
        t122 += v9 * b11;
        t13 += v9 * b12;
        t14 += v9 * b13;
        t15 += v9 * b14;
        t16 += v9 * b15;
        v9 = a13[2];
        t22 += v9 * b0;
        t32 += v9 * b1;
        t42 += v9 * b22;
        t52 += v9 * b32;
        t62 += v9 * b42;
        t72 += v9 * b52;
        t82 += v9 * b62;
        t92 += v9 * b72;
        t102 += v9 * b82;
        t112 += v9 * b92;
        t122 += v9 * b10;
        t13 += v9 * b11;
        t14 += v9 * b12;
        t15 += v9 * b13;
        t16 += v9 * b14;
        t17 += v9 * b15;
        v9 = a13[3];
        t32 += v9 * b0;
        t42 += v9 * b1;
        t52 += v9 * b22;
        t62 += v9 * b32;
        t72 += v9 * b42;
        t82 += v9 * b52;
        t92 += v9 * b62;
        t102 += v9 * b72;
        t112 += v9 * b82;
        t122 += v9 * b92;
        t13 += v9 * b10;
        t14 += v9 * b11;
        t15 += v9 * b12;
        t16 += v9 * b13;
        t17 += v9 * b14;
        t18 += v9 * b15;
        v9 = a13[4];
        t42 += v9 * b0;
        t52 += v9 * b1;
        t62 += v9 * b22;
        t72 += v9 * b32;
        t82 += v9 * b42;
        t92 += v9 * b52;
        t102 += v9 * b62;
        t112 += v9 * b72;
        t122 += v9 * b82;
        t13 += v9 * b92;
        t14 += v9 * b10;
        t15 += v9 * b11;
        t16 += v9 * b12;
        t17 += v9 * b13;
        t18 += v9 * b14;
        t19 += v9 * b15;
        v9 = a13[5];
        t52 += v9 * b0;
        t62 += v9 * b1;
        t72 += v9 * b22;
        t82 += v9 * b32;
        t92 += v9 * b42;
        t102 += v9 * b52;
        t112 += v9 * b62;
        t122 += v9 * b72;
        t13 += v9 * b82;
        t14 += v9 * b92;
        t15 += v9 * b10;
        t16 += v9 * b11;
        t17 += v9 * b12;
        t18 += v9 * b13;
        t19 += v9 * b14;
        t20 += v9 * b15;
        v9 = a13[6];
        t62 += v9 * b0;
        t72 += v9 * b1;
        t82 += v9 * b22;
        t92 += v9 * b32;
        t102 += v9 * b42;
        t112 += v9 * b52;
        t122 += v9 * b62;
        t13 += v9 * b72;
        t14 += v9 * b82;
        t15 += v9 * b92;
        t16 += v9 * b10;
        t17 += v9 * b11;
        t18 += v9 * b12;
        t19 += v9 * b13;
        t20 += v9 * b14;
        t21 += v9 * b15;
        v9 = a13[7];
        t72 += v9 * b0;
        t82 += v9 * b1;
        t92 += v9 * b22;
        t102 += v9 * b32;
        t112 += v9 * b42;
        t122 += v9 * b52;
        t13 += v9 * b62;
        t14 += v9 * b72;
        t15 += v9 * b82;
        t16 += v9 * b92;
        t17 += v9 * b10;
        t18 += v9 * b11;
        t19 += v9 * b12;
        t20 += v9 * b13;
        t21 += v9 * b14;
        t222 += v9 * b15;
        v9 = a13[8];
        t82 += v9 * b0;
        t92 += v9 * b1;
        t102 += v9 * b22;
        t112 += v9 * b32;
        t122 += v9 * b42;
        t13 += v9 * b52;
        t14 += v9 * b62;
        t15 += v9 * b72;
        t16 += v9 * b82;
        t17 += v9 * b92;
        t18 += v9 * b10;
        t19 += v9 * b11;
        t20 += v9 * b12;
        t21 += v9 * b13;
        t222 += v9 * b14;
        t23 += v9 * b15;
        v9 = a13[9];
        t92 += v9 * b0;
        t102 += v9 * b1;
        t112 += v9 * b22;
        t122 += v9 * b32;
        t13 += v9 * b42;
        t14 += v9 * b52;
        t15 += v9 * b62;
        t16 += v9 * b72;
        t17 += v9 * b82;
        t18 += v9 * b92;
        t19 += v9 * b10;
        t20 += v9 * b11;
        t21 += v9 * b12;
        t222 += v9 * b13;
        t23 += v9 * b14;
        t24 += v9 * b15;
        v9 = a13[10];
        t102 += v9 * b0;
        t112 += v9 * b1;
        t122 += v9 * b22;
        t13 += v9 * b32;
        t14 += v9 * b42;
        t15 += v9 * b52;
        t16 += v9 * b62;
        t17 += v9 * b72;
        t18 += v9 * b82;
        t19 += v9 * b92;
        t20 += v9 * b10;
        t21 += v9 * b11;
        t222 += v9 * b12;
        t23 += v9 * b13;
        t24 += v9 * b14;
        t25 += v9 * b15;
        v9 = a13[11];
        t112 += v9 * b0;
        t122 += v9 * b1;
        t13 += v9 * b22;
        t14 += v9 * b32;
        t15 += v9 * b42;
        t16 += v9 * b52;
        t17 += v9 * b62;
        t18 += v9 * b72;
        t19 += v9 * b82;
        t20 += v9 * b92;
        t21 += v9 * b10;
        t222 += v9 * b11;
        t23 += v9 * b12;
        t24 += v9 * b13;
        t25 += v9 * b14;
        t26 += v9 * b15;
        v9 = a13[12];
        t122 += v9 * b0;
        t13 += v9 * b1;
        t14 += v9 * b22;
        t15 += v9 * b32;
        t16 += v9 * b42;
        t17 += v9 * b52;
        t18 += v9 * b62;
        t19 += v9 * b72;
        t20 += v9 * b82;
        t21 += v9 * b92;
        t222 += v9 * b10;
        t23 += v9 * b11;
        t24 += v9 * b12;
        t25 += v9 * b13;
        t26 += v9 * b14;
        t27 += v9 * b15;
        v9 = a13[13];
        t13 += v9 * b0;
        t14 += v9 * b1;
        t15 += v9 * b22;
        t16 += v9 * b32;
        t17 += v9 * b42;
        t18 += v9 * b52;
        t19 += v9 * b62;
        t20 += v9 * b72;
        t21 += v9 * b82;
        t222 += v9 * b92;
        t23 += v9 * b10;
        t24 += v9 * b11;
        t25 += v9 * b12;
        t26 += v9 * b13;
        t27 += v9 * b14;
        t28 += v9 * b15;
        v9 = a13[14];
        t14 += v9 * b0;
        t15 += v9 * b1;
        t16 += v9 * b22;
        t17 += v9 * b32;
        t18 += v9 * b42;
        t19 += v9 * b52;
        t20 += v9 * b62;
        t21 += v9 * b72;
        t222 += v9 * b82;
        t23 += v9 * b92;
        t24 += v9 * b10;
        t25 += v9 * b11;
        t26 += v9 * b12;
        t27 += v9 * b13;
        t28 += v9 * b14;
        t29 += v9 * b15;
        v9 = a13[15];
        t15 += v9 * b0;
        t16 += v9 * b1;
        t17 += v9 * b22;
        t18 += v9 * b32;
        t19 += v9 * b42;
        t20 += v9 * b52;
        t21 += v9 * b62;
        t222 += v9 * b72;
        t23 += v9 * b82;
        t24 += v9 * b92;
        t25 += v9 * b10;
        t26 += v9 * b11;
        t27 += v9 * b12;
        t28 += v9 * b13;
        t29 += v9 * b14;
        t30 += v9 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t32 += 38 * t19;
        t42 += 38 * t20;
        t52 += 38 * t21;
        t62 += 38 * t222;
        t72 += 38 * t23;
        t82 += 38 * t24;
        t92 += 38 * t25;
        t102 += 38 * t26;
        t112 += 38 * t27;
        t122 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c14 = 1;
        v9 = t0 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t0 = v9 - c14 * 65536;
        v9 = t1 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t1 = v9 - c14 * 65536;
        v9 = t22 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t22 = v9 - c14 * 65536;
        v9 = t32 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t32 = v9 - c14 * 65536;
        v9 = t42 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t42 = v9 - c14 * 65536;
        v9 = t52 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t52 = v9 - c14 * 65536;
        v9 = t62 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t62 = v9 - c14 * 65536;
        v9 = t72 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t72 = v9 - c14 * 65536;
        v9 = t82 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t82 = v9 - c14 * 65536;
        v9 = t92 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t92 = v9 - c14 * 65536;
        v9 = t102 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t102 = v9 - c14 * 65536;
        v9 = t112 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t112 = v9 - c14 * 65536;
        v9 = t122 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t122 = v9 - c14 * 65536;
        v9 = t13 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t13 = v9 - c14 * 65536;
        v9 = t14 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t14 = v9 - c14 * 65536;
        v9 = t15 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t15 = v9 - c14 * 65536;
        t0 += c14 - 1 + 37 * (c14 - 1);
        c14 = 1;
        v9 = t0 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t0 = v9 - c14 * 65536;
        v9 = t1 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t1 = v9 - c14 * 65536;
        v9 = t22 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t22 = v9 - c14 * 65536;
        v9 = t32 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t32 = v9 - c14 * 65536;
        v9 = t42 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t42 = v9 - c14 * 65536;
        v9 = t52 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t52 = v9 - c14 * 65536;
        v9 = t62 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t62 = v9 - c14 * 65536;
        v9 = t72 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t72 = v9 - c14 * 65536;
        v9 = t82 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t82 = v9 - c14 * 65536;
        v9 = t92 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t92 = v9 - c14 * 65536;
        v9 = t102 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t102 = v9 - c14 * 65536;
        v9 = t112 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t112 = v9 - c14 * 65536;
        v9 = t122 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t122 = v9 - c14 * 65536;
        v9 = t13 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t13 = v9 - c14 * 65536;
        v9 = t14 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t14 = v9 - c14 * 65536;
        v9 = t15 + c14 + 65535;
        c14 = Math.floor(v9 / 65536);
        t15 = v9 - c14 * 65536;
        t0 += c14 - 1 + 37 * (c14 - 1);
        o13[0] = t0;
        o13[1] = t1;
        o13[2] = t22;
        o13[3] = t32;
        o13[4] = t42;
        o13[5] = t52;
        o13[6] = t62;
        o13[7] = t72;
        o13[8] = t82;
        o13[9] = t92;
        o13[10] = t102;
        o13[11] = t112;
        o13[12] = t122;
        o13[13] = t13;
        o13[14] = t14;
        o13[15] = t15;
      }
      function S8(o13, a13) {
        M6(o13, a13, a13);
      }
      function inv25519(o13, i48) {
        var c14 = gf();
        var a13;
        for (a13 = 0; a13 < 16; a13++)
          c14[a13] = i48[a13];
        for (a13 = 253; a13 >= 0; a13--) {
          S8(c14, c14);
          if (a13 !== 2 && a13 !== 4)
            M6(c14, c14, i48);
        }
        for (a13 = 0; a13 < 16; a13++)
          o13[a13] = c14[a13];
      }
      function pow2523(o13, i48) {
        var c14 = gf();
        var a13;
        for (a13 = 0; a13 < 16; a13++)
          c14[a13] = i48[a13];
        for (a13 = 250; a13 >= 0; a13--) {
          S8(c14, c14);
          if (a13 !== 1)
            M6(c14, c14, i48);
        }
        for (a13 = 0; a13 < 16; a13++)
          o13[a13] = c14[a13];
      }
      function crypto_scalarmult(q4, n24, p12) {
        var z4 = new Uint8Array(32);
        var x8 = new Float64Array(80), r23, i48;
        var a13 = gf(), b9 = gf(), c14 = gf(), d9 = gf(), e3 = gf(), f13 = gf();
        for (i48 = 0; i48 < 31; i48++)
          z4[i48] = n24[i48];
        z4[31] = n24[31] & 127 | 64;
        z4[0] &= 248;
        unpack25519(x8, p12);
        for (i48 = 0; i48 < 16; i48++) {
          b9[i48] = x8[i48];
          d9[i48] = a13[i48] = c14[i48] = 0;
        }
        a13[0] = d9[0] = 1;
        for (i48 = 254; i48 >= 0; --i48) {
          r23 = z4[i48 >>> 3] >>> (i48 & 7) & 1;
          sel25519(a13, b9, r23);
          sel25519(c14, d9, r23);
          A13(e3, a13, c14);
          Z5(a13, a13, c14);
          A13(c14, b9, d9);
          Z5(b9, b9, d9);
          S8(d9, e3);
          S8(f13, a13);
          M6(a13, c14, a13);
          M6(c14, b9, e3);
          A13(e3, a13, c14);
          Z5(a13, a13, c14);
          S8(b9, a13);
          Z5(c14, d9, f13);
          M6(a13, c14, _121665);
          A13(a13, a13, d9);
          M6(c14, c14, a13);
          M6(a13, d9, f13);
          M6(d9, b9, x8);
          S8(b9, e3);
          sel25519(a13, b9, r23);
          sel25519(c14, d9, r23);
        }
        for (i48 = 0; i48 < 16; i48++) {
          x8[i48 + 16] = a13[i48];
          x8[i48 + 32] = c14[i48];
          x8[i48 + 48] = b9[i48];
          x8[i48 + 64] = d9[i48];
        }
        var x32 = x8.subarray(32);
        var x16 = x8.subarray(16);
        inv25519(x32, x32);
        M6(x16, x16, x32);
        pack25519(q4, x16);
        return 0;
      }
      function crypto_scalarmult_base(q4, n24) {
        return crypto_scalarmult(q4, n24, _9);
      }
      function crypto_box_keypair(y10, x8) {
        randombytes(x8, 32);
        return crypto_scalarmult_base(y10, x8);
      }
      function crypto_box_beforenm(k3, y10, x8) {
        var s12 = new Uint8Array(32);
        crypto_scalarmult(s12, x8, y10);
        return crypto_core_hsalsa20(k3, _0, s12, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c14, m12, d9, n24, y10, x8) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y10, x8);
        return crypto_box_afternm(c14, m12, d9, n24, k3);
      }
      function crypto_box_open(m12, c14, d9, n24, y10, x8) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y10, x8);
        return crypto_box_open_afternm(m12, c14, d9, n24, k3);
      }
      var K5 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m12, n24) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i48, j4, h14, l12, a13, b9, c14, d9;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n24 >= 128) {
          for (i48 = 0; i48 < 16; i48++) {
            j4 = 8 * i48 + pos;
            wh[i48] = m12[j4 + 0] << 24 | m12[j4 + 1] << 16 | m12[j4 + 2] << 8 | m12[j4 + 3];
            wl[i48] = m12[j4 + 4] << 24 | m12[j4 + 5] << 16 | m12[j4 + 6] << 8 | m12[j4 + 7];
          }
          for (i48 = 0; i48 < 80; i48++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h14 = ah7;
            l12 = al7;
            a13 = l12 & 65535;
            b9 = l12 >>> 16;
            c14 = h14 & 65535;
            d9 = h14 >>> 16;
            h14 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l12 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            h14 = ah4 & ah5 ^ ~ah4 & ah6;
            l12 = al4 & al5 ^ ~al4 & al6;
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            h14 = K5[i48 * 2];
            l12 = K5[i48 * 2 + 1];
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            h14 = wh[i48 % 16];
            l12 = wl[i48 % 16];
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            b9 += a13 >>> 16;
            c14 += b9 >>> 16;
            d9 += c14 >>> 16;
            th = c14 & 65535 | d9 << 16;
            tl = a13 & 65535 | b9 << 16;
            h14 = th;
            l12 = tl;
            a13 = l12 & 65535;
            b9 = l12 >>> 16;
            c14 = h14 & 65535;
            d9 = h14 >>> 16;
            h14 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l12 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            h14 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l12 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            b9 += a13 >>> 16;
            c14 += b9 >>> 16;
            d9 += c14 >>> 16;
            bh7 = c14 & 65535 | d9 << 16;
            bl7 = a13 & 65535 | b9 << 16;
            h14 = bh3;
            l12 = bl3;
            a13 = l12 & 65535;
            b9 = l12 >>> 16;
            c14 = h14 & 65535;
            d9 = h14 >>> 16;
            h14 = th;
            l12 = tl;
            a13 += l12 & 65535;
            b9 += l12 >>> 16;
            c14 += h14 & 65535;
            d9 += h14 >>> 16;
            b9 += a13 >>> 16;
            c14 += b9 >>> 16;
            d9 += c14 >>> 16;
            bh3 = c14 & 65535 | d9 << 16;
            bl3 = a13 & 65535 | b9 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i48 % 16 === 15) {
              for (j4 = 0; j4 < 16; j4++) {
                h14 = wh[j4];
                l12 = wl[j4];
                a13 = l12 & 65535;
                b9 = l12 >>> 16;
                c14 = h14 & 65535;
                d9 = h14 >>> 16;
                h14 = wh[(j4 + 9) % 16];
                l12 = wl[(j4 + 9) % 16];
                a13 += l12 & 65535;
                b9 += l12 >>> 16;
                c14 += h14 & 65535;
                d9 += h14 >>> 16;
                th = wh[(j4 + 1) % 16];
                tl = wl[(j4 + 1) % 16];
                h14 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l12 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a13 += l12 & 65535;
                b9 += l12 >>> 16;
                c14 += h14 & 65535;
                d9 += h14 >>> 16;
                th = wh[(j4 + 14) % 16];
                tl = wl[(j4 + 14) % 16];
                h14 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l12 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a13 += l12 & 65535;
                b9 += l12 >>> 16;
                c14 += h14 & 65535;
                d9 += h14 >>> 16;
                b9 += a13 >>> 16;
                c14 += b9 >>> 16;
                d9 += c14 >>> 16;
                wh[j4] = c14 & 65535 | d9 << 16;
                wl[j4] = a13 & 65535 | b9 << 16;
              }
            }
          }
          h14 = ah0;
          l12 = al0;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[0];
          l12 = hl[0];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[0] = ah0 = c14 & 65535 | d9 << 16;
          hl[0] = al0 = a13 & 65535 | b9 << 16;
          h14 = ah1;
          l12 = al1;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[1];
          l12 = hl[1];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[1] = ah1 = c14 & 65535 | d9 << 16;
          hl[1] = al1 = a13 & 65535 | b9 << 16;
          h14 = ah2;
          l12 = al2;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[2];
          l12 = hl[2];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[2] = ah2 = c14 & 65535 | d9 << 16;
          hl[2] = al2 = a13 & 65535 | b9 << 16;
          h14 = ah3;
          l12 = al3;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[3];
          l12 = hl[3];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[3] = ah3 = c14 & 65535 | d9 << 16;
          hl[3] = al3 = a13 & 65535 | b9 << 16;
          h14 = ah4;
          l12 = al4;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[4];
          l12 = hl[4];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[4] = ah4 = c14 & 65535 | d9 << 16;
          hl[4] = al4 = a13 & 65535 | b9 << 16;
          h14 = ah5;
          l12 = al5;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[5];
          l12 = hl[5];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[5] = ah5 = c14 & 65535 | d9 << 16;
          hl[5] = al5 = a13 & 65535 | b9 << 16;
          h14 = ah6;
          l12 = al6;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[6];
          l12 = hl[6];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[6] = ah6 = c14 & 65535 | d9 << 16;
          hl[6] = al6 = a13 & 65535 | b9 << 16;
          h14 = ah7;
          l12 = al7;
          a13 = l12 & 65535;
          b9 = l12 >>> 16;
          c14 = h14 & 65535;
          d9 = h14 >>> 16;
          h14 = hh[7];
          l12 = hl[7];
          a13 += l12 & 65535;
          b9 += l12 >>> 16;
          c14 += h14 & 65535;
          d9 += h14 >>> 16;
          b9 += a13 >>> 16;
          c14 += b9 >>> 16;
          d9 += c14 >>> 16;
          hh[7] = ah7 = c14 & 65535 | d9 << 16;
          hl[7] = al7 = a13 & 65535 | b9 << 16;
          pos += 128;
          n24 -= 128;
        }
        return n24;
      }
      function crypto_hash(out, m12, n24) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x8 = new Uint8Array(256), i48, b9 = n24;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m12, n24);
        n24 %= 128;
        for (i48 = 0; i48 < n24; i48++)
          x8[i48] = m12[b9 - n24 + i48];
        x8[n24] = 128;
        n24 = 256 - 128 * (n24 < 112 ? 1 : 0);
        x8[n24 - 9] = 0;
        ts64(x8, n24 - 8, b9 / 536870912 | 0, b9 << 3);
        crypto_hashblocks_hl(hh, hl, x8, n24);
        for (i48 = 0; i48 < 8; i48++)
          ts64(out, 8 * i48, hh[i48], hl[i48]);
        return 0;
      }
      function add2(p12, q4) {
        var a13 = gf(), b9 = gf(), c14 = gf(), d9 = gf(), e3 = gf(), f13 = gf(), g9 = gf(), h14 = gf(), t13 = gf();
        Z5(a13, p12[1], p12[0]);
        Z5(t13, q4[1], q4[0]);
        M6(a13, a13, t13);
        A13(b9, p12[0], p12[1]);
        A13(t13, q4[0], q4[1]);
        M6(b9, b9, t13);
        M6(c14, p12[3], q4[3]);
        M6(c14, c14, D22);
        M6(d9, p12[2], q4[2]);
        A13(d9, d9, d9);
        Z5(e3, b9, a13);
        Z5(f13, d9, c14);
        A13(g9, d9, c14);
        A13(h14, b9, a13);
        M6(p12[0], e3, f13);
        M6(p12[1], h14, g9);
        M6(p12[2], g9, f13);
        M6(p12[3], e3, h14);
      }
      function cswap(p12, q4, b9) {
        var i48;
        for (i48 = 0; i48 < 4; i48++) {
          sel25519(p12[i48], q4[i48], b9);
        }
      }
      function pack(r23, p12) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p12[2]);
        M6(tx, p12[0], zi);
        M6(ty, p12[1], zi);
        pack25519(r23, ty);
        r23[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p12, q4, s12) {
        var b9, i48;
        set25519(p12[0], gf0);
        set25519(p12[1], gf1);
        set25519(p12[2], gf1);
        set25519(p12[3], gf0);
        for (i48 = 255; i48 >= 0; --i48) {
          b9 = s12[i48 / 8 | 0] >> (i48 & 7) & 1;
          cswap(p12, q4, b9);
          add2(q4, p12);
          add2(p12, p12);
          cswap(p12, q4, b9);
        }
      }
      function scalarbase(p12, s12) {
        var q4 = [gf(), gf(), gf(), gf()];
        set25519(q4[0], X4);
        set25519(q4[1], Y3);
        set25519(q4[2], gf1);
        M6(q4[3], X4, Y3);
        scalarmult(p12, q4, s12);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d9 = new Uint8Array(64);
        var p12 = [gf(), gf(), gf(), gf()];
        var i48;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d9, sk, 32);
        d9[0] &= 248;
        d9[31] &= 127;
        d9[31] |= 64;
        scalarbase(p12, d9);
        pack(pk, p12);
        for (i48 = 0; i48 < 32; i48++)
          sk[i48 + 32] = pk[i48];
        return 0;
      }
      var L4 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r23, x8) {
        var carry, i48, j4, k3;
        for (i48 = 63; i48 >= 32; --i48) {
          carry = 0;
          for (j4 = i48 - 32, k3 = i48 - 12; j4 < k3; ++j4) {
            x8[j4] += carry - 16 * x8[i48] * L4[j4 - (i48 - 32)];
            carry = Math.floor((x8[j4] + 128) / 256);
            x8[j4] -= carry * 256;
          }
          x8[j4] += carry;
          x8[i48] = 0;
        }
        carry = 0;
        for (j4 = 0; j4 < 32; j4++) {
          x8[j4] += carry - (x8[31] >> 4) * L4[j4];
          carry = x8[j4] >> 8;
          x8[j4] &= 255;
        }
        for (j4 = 0; j4 < 32; j4++)
          x8[j4] -= carry * L4[j4];
        for (i48 = 0; i48 < 32; i48++) {
          x8[i48 + 1] += x8[i48] >> 8;
          r23[i48] = x8[i48] & 255;
        }
      }
      function reduce(r23) {
        var x8 = new Float64Array(64), i48;
        for (i48 = 0; i48 < 64; i48++)
          x8[i48] = r23[i48];
        for (i48 = 0; i48 < 64; i48++)
          r23[i48] = 0;
        modL(r23, x8);
      }
      function crypto_sign(sm, m12, n24, sk) {
        var d9 = new Uint8Array(64), h14 = new Uint8Array(64), r23 = new Uint8Array(64);
        var i48, j4, x8 = new Float64Array(64);
        var p12 = [gf(), gf(), gf(), gf()];
        crypto_hash(d9, sk, 32);
        d9[0] &= 248;
        d9[31] &= 127;
        d9[31] |= 64;
        var smlen = n24 + 64;
        for (i48 = 0; i48 < n24; i48++)
          sm[64 + i48] = m12[i48];
        for (i48 = 0; i48 < 32; i48++)
          sm[32 + i48] = d9[32 + i48];
        crypto_hash(r23, sm.subarray(32), n24 + 32);
        reduce(r23);
        scalarbase(p12, r23);
        pack(sm, p12);
        for (i48 = 32; i48 < 64; i48++)
          sm[i48] = sk[i48];
        crypto_hash(h14, sm, n24 + 64);
        reduce(h14);
        for (i48 = 0; i48 < 64; i48++)
          x8[i48] = 0;
        for (i48 = 0; i48 < 32; i48++)
          x8[i48] = r23[i48];
        for (i48 = 0; i48 < 32; i48++) {
          for (j4 = 0; j4 < 32; j4++) {
            x8[i48 + j4] += h14[i48] * d9[j4];
          }
        }
        modL(sm.subarray(32), x8);
        return smlen;
      }
      function unpackneg(r23, p12) {
        var t13 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r23[2], gf1);
        unpack25519(r23[1], p12);
        S8(num, r23[1]);
        M6(den, num, D8);
        Z5(num, num, r23[2]);
        A13(den, r23[2], den);
        S8(den2, den);
        S8(den4, den2);
        M6(den6, den4, den2);
        M6(t13, den6, num);
        M6(t13, t13, den);
        pow2523(t13, t13);
        M6(t13, t13, num);
        M6(t13, t13, den);
        M6(t13, t13, den);
        M6(r23[0], t13, den);
        S8(chk, r23[0]);
        M6(chk, chk, den);
        if (neq25519(chk, num))
          M6(r23[0], r23[0], I5);
        S8(chk, r23[0]);
        M6(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r23[0]) === p12[31] >> 7)
          Z5(r23[0], gf0, r23[0]);
        M6(r23[3], r23[0], r23[1]);
        return 0;
      }
      function crypto_sign_open(m12, sm, n24, pk) {
        var i48;
        var t13 = new Uint8Array(32), h14 = new Uint8Array(64);
        var p12 = [gf(), gf(), gf(), gf()], q4 = [gf(), gf(), gf(), gf()];
        if (n24 < 64)
          return -1;
        if (unpackneg(q4, pk))
          return -1;
        for (i48 = 0; i48 < n24; i48++)
          m12[i48] = sm[i48];
        for (i48 = 0; i48 < 32; i48++)
          m12[i48 + 32] = pk[i48];
        crypto_hash(h14, m12, n24);
        reduce(h14);
        scalarmult(p12, q4, h14);
        scalarbase(q4, sm.subarray(32));
        add2(p12, q4);
        pack(t13, p12);
        n24 -= 64;
        if (crypto_verify_32(sm, 0, t13, 0)) {
          for (i48 = 0; i48 < n24; i48++)
            m12[i48] = 0;
          return -1;
        }
        for (i48 = 0; i48 < n24; i48++)
          m12[i48] = sm[i48 + 64];
        return n24;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D8,
        L: L4,
        pack25519,
        unpack25519,
        M: M6,
        A: A13,
        S: S8,
        Z: Z5,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k3, n24) {
        if (k3.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n24.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i48 = 0; i48 < arguments.length; i48++) {
          if (!(arguments[i48] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i48 = 0; i48 < arr.length; i48++)
          arr[i48] = 0;
      }
      nacl.randomBytes = function(n24) {
        var b9 = new Uint8Array(n24);
        randombytes(b9, n24);
        return b9;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m12 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c14 = new Uint8Array(m12.length);
        for (var i48 = 0; i48 < msg.length; i48++)
          m12[i48 + crypto_secretbox_ZEROBYTES] = msg[i48];
        crypto_secretbox(c14, m12, m12.length, nonce, key);
        return c14.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c14 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m12 = new Uint8Array(c14.length);
        for (var i48 = 0; i48 < box.length; i48++)
          c14[i48 + crypto_secretbox_BOXZEROBYTES] = box[i48];
        if (c14.length < 32)
          return null;
        if (crypto_secretbox_open(m12, c14, c14.length, nonce, key) !== 0)
          return null;
        return m12.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n24, p12) {
        checkArrayTypes(n24, p12);
        if (n24.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p12.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q4 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q4, n24, p12);
        return q4;
      };
      nacl.scalarMult.base = function(n24) {
        checkArrayTypes(n24);
        if (n24.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q4 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q4, n24);
        return q4;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k3);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k3, publicKey, secretKey);
        return k3;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k3);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m12 = new Uint8Array(mlen);
        for (var i48 = 0; i48 < m12.length; i48++)
          m12[i48] = tmp[i48];
        return m12;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i48 = 0; i48 < sig.length; i48++)
          sig[i48] = signedMsg[i48];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m12 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i48;
        for (i48 = 0; i48 < crypto_sign_BYTES; i48++)
          sm[i48] = sig[i48];
        for (i48 = 0; i48 < msg.length; i48++)
          sm[i48 + crypto_sign_BYTES] = msg[i48];
        return crypto_sign_open(m12, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i48 = 0; i48 < pk.length; i48++)
          pk[i48] = secretKey[32 + i48];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i48 = 0; i48 < 32; i48++)
          sk[i48] = seed[i48];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h14 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h14, msg, msg.length);
        return h14;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x8, y10) {
        checkArrayTypes(x8, y10);
        if (x8.length === 0 || y10.length === 0)
          return false;
        if (x8.length !== y10.length)
          return false;
        return vn(x8, 0, y10, 0, x8.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x8, n24) {
            var i48, v9 = new Uint8Array(n24);
            for (i48 = 0; i48 < n24; i48 += QUOTA) {
              crypto2.getRandomValues(v9.subarray(i48, i48 + Math.min(n24 - i48, QUOTA)));
            }
            for (i48 = 0; i48 < n24; i48++)
              x8[i48] = v9[i48];
            cleanup(v9);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x8, n24) {
              var i48, v9 = crypto2.randomBytes(n24);
              for (i48 = 0; i48 < n24; i48++)
                x8[i48] = v9[i48];
              cleanup(v9);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i48 = 0, l12 = handlers.length, ee2 = new Array(l12); i48 < l12; i48++) {
        ee2[i48] = handlers[i48].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i48;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
        }
        for (i48 = 1, args = new Array(len - 1); i48 < len; i48++) {
          args[i48 - 1] = arguments[i48];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j4;
        for (i48 = 0; i48 < length; i48++) {
          if (listeners[i48].once)
            this.removeListener(event, listeners[i48].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i48].fn.call(listeners[i48].context);
              break;
            case 2:
              listeners[i48].fn.call(listeners[i48].context, a1);
              break;
            case 3:
              listeners[i48].fn.call(listeners[i48].context, a1, a22);
              break;
            case 4:
              listeners[i48].fn.call(listeners[i48].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j4 = 1, args = new Array(len - 1); j4 < len; j4++) {
                  args[j4 - 1] = arguments[j4];
                }
              listeners[i48].fn.apply(listeners[i48].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i48 = 0, events = [], length = listeners.length; i48 < length; i48++) {
          if (listeners[i48].fn !== fn || once && !listeners[i48].once || context && listeners[i48].context !== context) {
            events.push(listeners[i48]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FBPNHF54.mjs
var s = class extends Error {
  constructor(e3, i48) {
    super(e3);
    this.invalidReason = i48;
  }
};

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes(a13) {
  return a13 instanceof Uint8Array || a13 != null && typeof a13 === "object" && a13.constructor.name === "Uint8Array";
}
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_5, i48) => i48.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!isBytes(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i48 = 0; i48 < bytes2.length; i48++) {
    hex2 += hexes[bytes2[i48]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n24 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n24 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n24;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i48 = 0; i48 < arrays.length; i48++) {
    const a13 = arrays[i48];
    if (!isBytes(a13))
      throw new Error("Uint8Array expected");
    sum += a13.length;
  }
  const res = new Uint8Array(sum);
  for (let i48 = 0, pad = 0; i48 < arrays.length; i48++) {
    const a13 = arrays[i48];
    res.set(a13, pad);
    pad += a13.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NL72WE3E.mjs
var l = ((e3) => (e3.TOO_SHORT = "too_short", e3.INVALID_LENGTH = "invalid_length", e3.INVALID_HEX_CHARS = "invalid_hex_chars", e3))(l || {});
var i = class n {
  constructor(t13) {
    this.data = t13;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromString(t13) {
    let r23 = t13;
    if (r23.startsWith("0x") && (r23 = r23.slice(2)), r23.length === 0)
      throw new s("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (r23.length % 2 !== 0)
      throw new s("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new n(hexToBytes(r23));
    } catch (e3) {
      throw new s(`Hex string contains invalid hex characters: ${e3 == null ? void 0 : e3.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(t13) {
    return t13 instanceof Uint8Array ? new n(t13) : n.fromString(t13);
  }
  static isValid(t13) {
    try {
      return n.fromString(t13), { valid: true };
    } catch (r23) {
      return { valid: false, invalidReason: r23 == null ? void 0 : r23.invalidReason, invalidReasonMessage: r23 == null ? void 0 : r23.message };
    }
  }
  equals(t13) {
    return this.data.length !== t13.data.length ? false : this.data.every((r23, e3) => r23 === t13.data[e3]);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-56CNRT2K.mjs
var t = 255;
var n2 = 65535;
var U = 4294967295;
var _ = 18446744073709551615n;
var o = 340282366920938463463374607431768211455n;
var i2 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FVA2OPG4.mjs
var h = Object.defineProperty;
var i3 = Object.getOwnPropertyDescriptor;
var j = (g9, b9, d9, c14) => {
  for (var a13 = c14 > 1 ? void 0 : c14 ? i3(b9, d9) : b9, e3 = g9.length - 1, f13; e3 >= 0; e3--)
    (f13 = g9[e3]) && (a13 = (c14 ? f13(b9, d9, a13) : f13(a13)) || a13);
  return c14 && a13 && h(b9, d9, a13), a13;
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-N4RBQZ2B.mjs
var B = class {
  bcsToBytes() {
    let e3 = new n3();
    return this.serialize(e3), e3.toUint8Array();
  }
  bcsToHex() {
    let e3 = this.bcsToBytes();
    return i.fromHexInput(e3);
  }
};
var n3 = class {
  constructor(e3 = 64) {
    if (e3 <= 0)
      throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(e3), this.offset = 0;
  }
  ensureBufferWillHandleSize(e3) {
    for (; this.buffer.byteLength < this.offset + e3; ) {
      let t13 = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(t13).set(new Uint8Array(this.buffer)), this.buffer = t13;
    }
  }
  appendToBuffer(e3) {
    this.ensureBufferWillHandleSize(e3.length), new Uint8Array(this.buffer, this.offset).set(e3), this.offset += e3.length;
  }
  serializeWithFunction(e3, t13, i48) {
    this.ensureBufferWillHandleSize(t13);
    let a13 = new DataView(this.buffer, this.offset);
    e3.apply(a13, [0, i48, true]), this.offset += t13;
  }
  serializeStr(e3) {
    let t13 = new TextEncoder();
    this.serializeBytes(t13.encode(e3));
  }
  serializeBytes(e3) {
    this.serializeU32AsUleb128(e3.length), this.appendToBuffer(e3);
  }
  serializeFixedBytes(e3) {
    this.appendToBuffer(e3);
  }
  serializeBool(e3) {
    A(e3);
    let t13 = e3 ? 1 : 0;
    this.appendToBuffer(new Uint8Array([t13]));
  }
  serializeU8(e3) {
    this.appendToBuffer(new Uint8Array([e3]));
  }
  serializeU16(e3) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, e3);
  }
  serializeU32(e3) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, e3);
  }
  serializeU64(e3) {
    let t13 = BigInt(e3) & BigInt(U), i48 = BigInt(e3) >> BigInt(32);
    this.serializeU32(Number(t13)), this.serializeU32(Number(i48));
  }
  serializeU128(e3) {
    let t13 = BigInt(e3) & _, i48 = BigInt(e3) >> BigInt(64);
    this.serializeU64(t13), this.serializeU64(i48);
  }
  serializeU256(e3) {
    let t13 = BigInt(e3) & o, i48 = BigInt(e3) >> BigInt(128);
    this.serializeU128(t13), this.serializeU128(i48);
  }
  serializeU32AsUleb128(e3) {
    let t13 = e3, i48 = [];
    for (; t13 >>> 7; )
      i48.push(t13 & 127 | 128), t13 >>>= 7;
    i48.push(t13), this.appendToBuffer(new Uint8Array(i48));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(e3) {
    e3.serialize(this);
  }
  serializeVector(e3) {
    this.serializeU32AsUleb128(e3.length), e3.forEach((t13) => {
      t13.serialize(this);
    });
  }
};
j([o2(0, t)], n3.prototype, "serializeU8", 1), j([o2(0, n2)], n3.prototype, "serializeU16", 1), j([o2(0, U)], n3.prototype, "serializeU32", 1), j([o2(BigInt(0), _)], n3.prototype, "serializeU64", 1), j([o2(BigInt(0), o)], n3.prototype, "serializeU128", 1), j([o2(BigInt(0), i2)], n3.prototype, "serializeU256", 1), j([o2(0, U)], n3.prototype, "serializeU32AsUleb128", 1);
function A(r23) {
  if (typeof r23 != "boolean")
    throw new Error(`${r23} is not a boolean value`);
}
var g = (r23, e3, t13) => `${r23} is out of range: [${e3}, ${t13}]`;
function w(r23, e3, t13) {
  let i48 = BigInt(r23);
  if (i48 > BigInt(t13) || i48 < BigInt(e3))
    throw new Error(g(r23, e3, t13));
}
function o2(r23, e3) {
  return (t13, i48, a13) => {
    let p12 = a13.value;
    return a13.value = function(l12) {
      return w(l12, r23, e3), p12.apply(this, [l12]);
    }, a13;
  };
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-F7CR75CJ.mjs
var h2 = ((s12) => (s12.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", s12.INVALID_HEX_CHARS = "invalid_hex_chars", s12.TOO_SHORT = "too_short", s12.TOO_LONG = "too_long", s12.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", s12.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", s12.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", s12))(h2 || {});
var r = class r2 extends B {
  constructor(t13) {
    super();
    if (t13.length !== r2.LENGTH)
      throw new s("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = t13;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((t13) => t13 === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let t13 = bytesToHex(this.data);
    return this.isSpecial() && (t13 = t13[t13.length - 1]), t13;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(t13) {
    t13.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(t13) {
    let e3 = this.bcsToBytes();
    t13.serializeBytes(e3);
  }
  serializeForScriptFunction(t13) {
    t13.serializeU32AsUleb128(3), t13.serialize(this);
  }
  static deserialize(t13) {
    let e3 = t13.deserializeFixedBytes(r2.LENGTH);
    return new r2(e3);
  }
  static fromStringStrict(t13) {
    if (!t13.startsWith("0x"))
      throw new s("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let e3 = r2.fromString(t13);
    if (t13.length !== r2.LONG_STRING_LENGTH + 2)
      if (e3.isSpecial()) {
        if (t13.length !== 3)
          throw new s(`The given hex string ${t13} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
      } else
        throw new s(`The given hex string ${t13} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return e3;
  }
  static fromString(t13) {
    let e3 = t13;
    if (t13.startsWith("0x") && (e3 = t13.slice(2)), e3.length === 0)
      throw new s("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (e3.length > 64)
      throw new s("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    let n24;
    try {
      n24 = hexToBytes(e3.padStart(64, "0"));
    } catch (d9) {
      throw new s(`Hex characters are invalid: ${d9 == null ? void 0 : d9.message}`, "invalid_hex_chars");
    }
    return new r2(n24);
  }
  static from(t13) {
    return t13 instanceof r2 ? t13 : t13 instanceof Uint8Array ? new r2(t13) : r2.fromString(t13);
  }
  static fromStrict(t13) {
    return t13 instanceof r2 ? t13 : t13 instanceof Uint8Array ? new r2(t13) : r2.fromStringStrict(t13);
  }
  static isValid(t13) {
    try {
      return t13.strict ? r2.fromStrict(t13.input) : r2.from(t13.input), { valid: true };
    } catch (e3) {
      return { valid: false, invalidReason: e3 == null ? void 0 : e3.invalidReason, invalidReasonMessage: e3 == null ? void 0 : e3.message };
    }
  }
  equals(t13) {
    return this.data.length !== t13.data.length ? false : this.data.every((e3, n24) => e3 === t13.data[n24]);
  }
};
r.LENGTH = 32, r.LONG_STRING_LENGTH = 64, r.ZERO = r.from("0x0"), r.ONE = r.from("0x1"), r.TWO = r.from("0x2"), r.THREE = r.from("0x3"), r.FOUR = r.from("0x4");
var c = r;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BQSE5HHW.mjs
var i4 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var a = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
}
    `;
var s2 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var _2 = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var u = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var c2 = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var d = `
    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var l2 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var y = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var p = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var m = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var g2 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var b = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var T = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
var k = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var $ = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var f = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
var v = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var h3 = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
  }
}
    `;
var A2 = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${a}`;
var w2 = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var G = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
var C = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${i4}`;
var q = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var Q = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6FBKUTGF.mjs
var s3 = class extends Error {
  constructor(e3, t13, a13) {
    super(a13);
    this.name = "AptosApiError", this.url = t13.url, this.status = t13.status, this.statusText = t13.statusText, this.data = t13.data, this.request = e3;
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3UYBNX3P.mjs
var o3 = "1.6.0";

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-T5IFXLOP.mjs
var l3 = { 400: "Bad Request", 401: "Unauthorized", 403: "Forbidden", 404: "Not Found", 429: "Too Many Requests", 500: "Internal Server Error", 502: "Bad Gateway", 503: "Service Unavailable" };
async function c3(o13, a13) {
  let { url: r23, method: i48, body: u10, contentType: s12, params: e3, overrides: t13 } = o13, n24 = { ...t13 == null ? void 0 : t13.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o3}`, "content-type": s12 ?? "application/json" };
  return (t13 == null ? void 0 : t13.AUTH_TOKEN) && r23.includes("faucet") && (n24.Authorization = `Bearer ${t13 == null ? void 0 : t13.AUTH_TOKEN}`), (t13 == null ? void 0 : t13.API_KEY) && !r23.includes("faucet") && (n24.Authorization = `Bearer ${t13 == null ? void 0 : t13.API_KEY}`), a13.provider({ url: r23, method: i48, body: u10, params: e3, headers: n24, overrides: t13 });
}
async function T2(o13, a13) {
  let { url: r23, path: i48 } = o13, u10 = i48 ? `${r23}/${i48}` : r23, s12 = await c3({ ...o13, url: u10 }, a13.client), e3 = { status: s12.status, statusText: s12.statusText, data: s12.data, headers: s12.headers, config: s12.config, request: s12.request, url: u10 };
  if (a13.isIndexerRequest(r23)) {
    let n24 = e3.data;
    if (n24.errors)
      throw new s3(o13, e3, `Indexer error: ${n24.errors[0].message}` ?? `Indexer unhandled Error ${s12.status} : ${s12.statusText}`);
    e3.data = n24.data;
  }
  if (e3.status >= 200 && e3.status < 300)
    return e3;
  let t13;
  throw e3 && e3.data && "message" in e3.data && "error_code" in e3.data ? t13 = JSON.stringify(e3.data) : e3.status in l3 ? t13 = l3[e3.status] : t13 = `Unhandled Error ${e3.status} : ${e3.statusText}`, new s3(o13, e3, `${a13.isFullnodeRequest(r23) ? "Fullnode" : "Faucet"} error: ${t13}`);
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IKCBGNRD.mjs
async function p2(e3) {
  let { aptosConfig: t13, overrides: s12, params: n24, contentType: o13, acceptType: i48, path: a13, originMethod: u10, type: R4 } = e3, d9 = t13.getRequestUrl(R4);
  return T2({ url: d9, method: "GET", originMethod: u10, path: a13, contentType: o13 == null ? void 0 : o13.valueOf(), acceptType: i48 == null ? void 0 : i48.valueOf(), params: n24, overrides: { ...t13.clientConfig, ...s12 } }, t13);
}
async function g3(e3) {
  return p2({ ...e3, type: 0 });
}
async function f2(e3) {
  let t13 = [], s12, n24 = e3.params;
  do {
    let o13 = await p2({ type: 0, aptosConfig: e3.aptosConfig, originMethod: e3.originMethod, path: e3.path, params: n24, overrides: e3.overrides });
    s12 = o13.headers["x-aptos-cursor"], delete o13.headers, t13.push(...o13.data), n24.start = s12;
  } while (s12 != null);
  return t13;
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YE3DZD6T.mjs
async function s4(e3) {
  let { type: p12, originMethod: n24, path: i48, body: r23, acceptType: R4, contentType: y10, params: u10, aptosConfig: t13, overrides: m12 } = e3, c14 = t13.getRequestUrl(p12);
  return T2({ url: c14, method: "POST", originMethod: n24, path: i48, body: r23, contentType: y10 == null ? void 0 : y10.valueOf(), acceptType: R4 == null ? void 0 : R4.valueOf(), params: u10, overrides: { ...t13.clientConfig, ...m12 } }, t13);
}
async function A3(e3) {
  return s4({ ...e3, type: 0 });
}
async function f3(e3) {
  return s4({ ...e3, type: 1 });
}
async function x(e3) {
  return s4({ ...e3, type: 2 });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DRF6AMEZ.mjs
async function l4(o13) {
  let { aptosConfig: e3 } = o13, { data: t13 } = await g3({ aptosConfig: e3, originMethod: "getLedgerInfo", path: "" });
  return t13;
}
async function h4(o13) {
  let { aptosConfig: e3, ledgerVersion: t13, options: s12 } = o13, { data: r23 } = await g3({ aptosConfig: e3, originMethod: "getBlockByVersion", path: `blocks/by_version/${t13}`, params: { with_transactions: s12 == null ? void 0 : s12.withTransactions } });
  return r23;
}
async function m2(o13) {
  let { aptosConfig: e3, blockHeight: t13, options: s12 } = o13, { data: r23 } = await g3({ aptosConfig: e3, originMethod: "getBlockByHeight", path: `blocks/by_height/${t13}`, params: { with_transactions: s12 == null ? void 0 : s12.withTransactions } });
  return r23;
}
async function C2(o13) {
  let { aptosConfig: e3, handle: t13, data: s12, options: r23 } = o13;
  return (await A3({ aptosConfig: e3, originMethod: "getTableItem", path: `tables/${t13}/item`, params: { ledger_version: r23 == null ? void 0 : r23.ledgerVersion }, body: s12 })).data;
}
async function T3(o13) {
  let { aptosConfig: e3, payload: t13, options: s12 } = o13, { data: r23 } = await A3({ aptosConfig: e3, originMethod: "view", path: "view", params: { ledger_version: s12 == null ? void 0 : s12.ledgerVersion }, body: { function: t13.function, type_arguments: t13.typeArguments ?? [], arguments: t13.functionArguments ?? [] } });
  return r23;
}
async function q2(o13) {
  let { aptosConfig: e3, limit: t13 } = o13;
  return (await p3({ aptosConfig: e3, query: { query: b, variables: { limit: t13 } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function p3(o13) {
  let { aptosConfig: e3, query: t13, originMethod: s12 } = o13, { data: r23 } = await f3({ aptosConfig: e3, originMethod: s12 ?? "queryIndexer", path: "", body: t13, overrides: { WITH_CREDENTIALS: false } });
  return r23;
}
async function f4(o13) {
  let { aptosConfig: e3 } = o13;
  return (await p3({ aptosConfig: e3, query: { query: G }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function w3(o13) {
  let e3 = await f4({ aptosConfig: o13.aptosConfig });
  return BigInt(e3[0].last_success_version);
}
async function A4(o13) {
  let { aptosConfig: e3, processorType: t13 } = o13, s12 = { processor: { _eq: t13.valueOf() } };
  return (await p3({ aptosConfig: e3, query: { query: G, variables: { where_condition: s12 } }, originMethod: "getProcessorStatus" })).processor_status[0];
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XOBXX273.mjs
async function m3(e3) {
  let { aptosConfig: t13, poolAddress: o13 } = e3, r23 = c.from(o13).toStringLong(), i48 = await p3({ aptosConfig: t13, query: { query: w2, variables: { where_condition: { pool_address: { _eq: r23 } } } } });
  return i48.num_active_delegator_per_pool[0] ? i48.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function f5(e3) {
  let { aptosConfig: t13, options: o13 } = e3, r23 = { query: w2, variables: { order_by: o13 == null ? void 0 : o13.orderBy } };
  return (await p3({ aptosConfig: t13, query: r23 })).num_active_delegator_per_pool;
}
async function A5(e3) {
  let { aptosConfig: t13, delegatorAddress: o13, poolAddress: r23 } = e3, a13 = { query: $, variables: { delegatorAddress: c.from(o13).toStringLong(), poolAddress: c.from(r23).toStringLong() } };
  return (await p3({ aptosConfig: t13, query: a13 })).delegated_staking_activities;
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AH44UPM4.mjs
var n4 = /* @__PURE__ */ new Map();
function m4(r23, e3, t13) {
  return async (...s12) => {
    if (n4.has(e3)) {
      let { value: i48, timestamp: u10 } = n4.get(e3);
      if (t13 === void 0 || Date.now() - u10 <= t13)
        return i48;
    }
    let a13 = await r23(...s12);
    return n4.set(e3, { value: a13, timestamp: Date.now() }), a13;
  };
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HHJBCGAQ.mjs
var S = ((E6) => (E6[E6.FULLNODE = 0] = "FULLNODE", E6[E6.INDEXER = 1] = "INDEXER", E6[E6.FAUCET = 2] = "FAUCET", E6))(S || {});
var n5 = "devnet";
var o4 = 2e5;
var N = 20;
var T4 = 20;
var A6 = "0x1::aptos_coin::AptosCoin";
var a2 = "APTOS::RawTransaction";
var r3 = "APTOS::RawTransactionWithData";
var t2 = ((_5) => (_5.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", _5.DEFAULT = "default_processor", _5.EVENTS_PROCESSOR = "events_processor", _5.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", _5.STAKE_PROCESSOR = "stake_processor", _5.TOKEN_V2_PROCESSOR = "token_v2_processor", _5.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", _5))(t2 || {});

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3JPVQHOR.mjs
async function r4(e3) {
  return new Promise((n24) => {
    setTimeout(n24, e3);
  });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A2QH4A6D.mjs
async function F(o13) {
  let { aptosConfig: n24, options: t13 } = o13;
  return f2({ aptosConfig: n24, originMethod: "getTransactions", path: "transactions", params: { start: t13 == null ? void 0 : t13.offset, limit: t13 == null ? void 0 : t13.limit } });
}
async function L(o13) {
  let { aptosConfig: n24 } = o13;
  return m4(async () => {
    let { data: t13 } = await g3({ aptosConfig: n24, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return t13;
  }, `gas-price-${n24.network}`, 1e3 * 60 * 5)();
}
async function v2(o13) {
  let { aptosConfig: n24, ledgerVersion: t13 } = o13, { data: s12 } = await g3({ aptosConfig: n24, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t13}` });
  return s12;
}
async function x2(o13) {
  let { aptosConfig: n24, transactionHash: t13 } = o13, { data: s12 } = await g3({ aptosConfig: n24, path: `transactions/by_hash/${t13}`, originMethod: "getTransactionByHash" });
  return s12;
}
async function N2(o13) {
  let { aptosConfig: n24, transactionHash: t13 } = o13;
  try {
    return (await x2({ aptosConfig: n24, transactionHash: t13 })).type === "pending_transaction";
  } catch (s12) {
    if ((s12 == null ? void 0 : s12.status) === 404)
      return true;
    throw s12;
  }
}
async function G2(o13) {
  let { aptosConfig: n24, transactionHash: t13, options: s12 } = o13, r23 = (s12 == null ? void 0 : s12.timeoutSecs) ?? T4, f13 = (s12 == null ? void 0 : s12.checkSuccess) ?? true, i48 = true, u10 = 0, e3, g9, m12 = 200, P6 = 1.5;
  for (; i48 && !(u10 >= r23); ) {
    try {
      if (e3 = await x2({ aptosConfig: n24, transactionHash: t13 }), i48 = e3.type === "pending_transaction", !i48)
        break;
    } catch (a13) {
      if (!(a13 instanceof s3) || (g9 = a13, a13.status !== 404 && a13.status >= 400 && a13.status < 500))
        throw a13;
    }
    await r4(m12), u10 += m12 / 1e3, m12 *= P6;
  }
  if (e3 === void 0)
    throw g9 || new p4(`Fetching transaction ${t13} failed and timed out after ${r23} seconds`, e3);
  if (e3.type === "pending_transaction")
    throw new p4(`Transaction ${t13} timed out in pending state after ${r23} seconds`, e3);
  if (!f13)
    return e3;
  if (!e3.success)
    throw new T5(`Transaction ${t13} failed with an error: ${e3.vm_status}`, e3);
  return e3;
}
async function D(o13) {
  let { aptosConfig: n24, processorType: t13 } = o13, s12 = BigInt(o13.minimumLedgerVersion), r23 = 3e3, f13 = (/* @__PURE__ */ new Date()).getTime(), i48 = BigInt(-1);
  for (; i48 < s12; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - f13 > r23)
      throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (t13 === void 0 ? i48 = await w3({ aptosConfig: n24 }) : i48 = (await A4({ aptosConfig: n24, processorType: t13 })).last_success_version, i48 >= s12)
      break;
    await r4(200);
  }
}
var p4 = class extends Error {
  constructor(t13, s12) {
    super(t13);
    this.lastSubmittedTransaction = s12;
  }
};
var T5 = class extends Error {
  constructor(t13, s12) {
    super(t13);
    this.transaction = s12;
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7JTOGYO7.mjs
async function i5(o13) {
  o13.minimumLedgerVersion !== void 0 && await D({ aptosConfig: o13.config, minimumLedgerVersion: o13.minimumLedgerVersion, processorType: o13.processorType });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RIL4SHXC.mjs
var t3 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getNumberOfDelegators(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "stake_processor" }), m3({ aptosConfig: this.config, ...e3 });
  }
  async getNumberOfDelegatorsForAllPools(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "stake_processor" }), f5({ aptosConfig: this.config, ...e3 });
  }
  async getDelegatedStakingActivities(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "stake_processor" }), A5({ aptosConfig: this.config, ...e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IHCIKE42.mjs
var r5 = class t4 extends B {
  constructor(i48) {
    super();
    this.identifier = i48;
  }
  serialize(i48) {
    i48.serializeStr(this.identifier);
  }
  static deserialize(i48) {
    let s12 = i48.deserializeStr();
    return new t4(s12);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-PJNPLRPR.mjs
var t5 = class extends B {
  static deserialize(e3) {
    let r23 = e3.deserializeUleb128AsU32();
    switch (r23) {
      case 0:
        return c4.load(e3);
      case 1:
        return u2.load(e3);
      case 2:
        return p5.load(e3);
      case 3:
        return z.load(e3);
      case 4:
        return S2.load(e3);
      case 5:
        return U2.load(e3);
      case 6:
        return y2.load(e3);
      case 7:
        return b2.load(e3);
      case 8:
        return d2.load(e3);
      case 9:
        return g4.load(e3);
      case 10:
        return T6.load(e3);
      case 255:
        return h5.load(e3);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${r23}`);
    }
  }
  isBool() {
    return this instanceof c4;
  }
  isAddress() {
    return this instanceof S2;
  }
  isGeneric() {
    return this instanceof h5;
  }
  isSigner() {
    return this instanceof U2;
  }
  isVector() {
    return this instanceof y2;
  }
  isStruct() {
    return this instanceof b2;
  }
  isU8() {
    return this instanceof u2;
  }
  isU16() {
    return this instanceof d2;
  }
  isU32() {
    return this instanceof g4;
  }
  isU64() {
    return this instanceof p5;
  }
  isU128() {
    return this instanceof z;
  }
  isU256() {
    return this instanceof T6;
  }
};
var c4 = class i6 extends t5 {
  toString() {
    return "bool";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(0);
  }
  static load(e3) {
    return new i6();
  }
};
var u2 = class i7 extends t5 {
  toString() {
    return "u8";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(1);
  }
  static load(e3) {
    return new i7();
  }
};
var d2 = class i8 extends t5 {
  toString() {
    return "u16";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(8);
  }
  static load(e3) {
    return new i8();
  }
};
var g4 = class i9 extends t5 {
  toString() {
    return "u32";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(9);
  }
  static load(e3) {
    return new i9();
  }
};
var p5 = class i10 extends t5 {
  toString() {
    return "u64";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(2);
  }
  static load(e3) {
    return new i10();
  }
};
var z = class i11 extends t5 {
  toString() {
    return "u128";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(3);
  }
  static load(e3) {
    return new i11();
  }
};
var T6 = class i12 extends t5 {
  toString() {
    return "u256";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(10);
  }
  static load(e3) {
    return new i12();
  }
};
var S2 = class i13 extends t5 {
  toString() {
    return "address";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(4);
  }
  static load(e3) {
    return new i13();
  }
};
var U2 = class i14 extends t5 {
  toString() {
    return "signer";
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(5);
  }
  static load(e3) {
    return new i14();
  }
};
var f6 = class i15 extends t5 {
  constructor(r23) {
    super();
    this.value = r23;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(r23) {
    r23.serializeU32AsUleb128(254);
  }
  static load(r23) {
    let s12 = t5.deserialize(r23);
    return new i15(s12);
  }
};
var h5 = class i16 extends t5 {
  constructor(r23) {
    super();
    this.value = r23;
    if (r23 < 0)
      throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(r23) {
    r23.serializeU32AsUleb128(255), r23.serializeU32(this.value);
  }
  static load(r23) {
    let s12 = r23.deserializeU32();
    return new i16(s12);
  }
};
var y2 = class i17 extends t5 {
  constructor(r23) {
    super();
    this.value = r23;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new i17(new u2());
  }
  serialize(r23) {
    r23.serializeU32AsUleb128(6), this.value.serialize(r23);
  }
  static load(r23) {
    let s12 = t5.deserialize(r23);
    return new i17(s12);
  }
};
var b2 = class i18 extends t5 {
  constructor(r23) {
    super();
    this.value = r23;
  }
  toString() {
    let r23 = "";
    return this.value.typeArgs.length > 0 && (r23 = `<${this.value.typeArgs.map((s12) => s12.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${r23}`;
  }
  serialize(r23) {
    r23.serializeU32AsUleb128(7), this.value.serialize(r23);
  }
  static load(r23) {
    let s12 = o5.deserialize(r23);
    return new i18(s12);
  }
  isTypeTag(r23, s12, l12) {
    return this.value.moduleName.identifier === s12 && this.value.name.identifier === l12 && this.value.address.equals(r23);
  }
  isString() {
    return this.isTypeTag(c.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(c.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(c.ONE, "object", "Object");
  }
};
var o5 = class i19 extends B {
  constructor(r23, s12, l12, v9) {
    super();
    this.address = r23, this.moduleName = s12, this.name = l12, this.typeArgs = v9;
  }
  serialize(r23) {
    r23.serialize(this.address), r23.serialize(this.moduleName), r23.serialize(this.name), r23.serializeVector(this.typeArgs);
  }
  static deserialize(r23) {
    let s12 = c.deserialize(r23), l12 = r5.deserialize(r23), v9 = r5.deserialize(r23), A13 = r23.deserializeVector(t5);
    return new i19(s12, l12, v9, A13);
  }
};
function E() {
  return new o5(c.ONE, new r5("aptos_coin"), new r5("AptosCoin"), []);
}
function V() {
  return new o5(c.ONE, new r5("string"), new r5("String"), []);
}
function j2(i48) {
  return new o5(c.ONE, new r5("option"), new r5("Option"), [i48]);
}
function G3(i48) {
  return new o5(c.ONE, new r5("object"), new r5("Object"), [i48]);
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OVSV4Y32.mjs
function N3(e3) {
  return !!e3.match(/^[_a-zA-Z0-9]+$/);
}
function V2(e3) {
  return !!e3.match(/\s/);
}
function $2(e3) {
  return !!e3.match(/^T[0-9]+$/);
}
function F2(e3, n24) {
  let i48 = n24;
  for (; i48 < e3.length; i48 += 1) {
    let c14 = e3[i48];
    if (!V2(c14))
      break;
  }
  return i48;
}
var S3 = ((t13) => (t13.InvalidTypeTag = "unknown type", t13.UnexpectedGenericType = "unexpected generic type", t13.UnexpectedTypeArgumentClose = "unexpected '>'", t13.UnexpectedWhitespaceCharacter = "unexpected whitespace character", t13.UnexpectedComma = "unexpected ','", t13.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", t13.MissingTypeArgumentClose = "no matching '>' for '<'", t13.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", t13.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", t13.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", t13.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", t13.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", t13))(S3 || {});
var r6 = class extends Error {
  constructor(n24, i48) {
    super(`Failed to parse typeTag '${n24}', ${i48}`);
  }
};
function Z(e3, n24) {
  let i48 = (n24 == null ? void 0 : n24.allowGenerics) ?? false, c14 = [], o13 = [], p12 = [], T10 = 0, a13 = "", u10 = 1;
  for (; T10 < e3.length; ) {
    let g9 = e3[T10];
    if (g9 === "<")
      c14.push({ savedExpectedTypes: u10, savedStr: a13, savedTypes: p12 }), a13 = "", p12 = [], u10 = 1;
    else if (g9 === ">") {
      if (a13 !== "") {
        let _5 = m5(a13, o13, i48);
        p12.push(_5);
      }
      let s12 = c14.pop();
      if (s12 === void 0)
        throw new r6(e3, "unexpected '>'");
      if (u10 !== p12.length)
        throw new r6(e3, "type argument count doesn't match expected amount");
      let { savedStr: h14, savedTypes: t13, savedExpectedTypes: W5 } = s12;
      o13 = p12, p12 = t13, a13 = h14, u10 = W5;
    } else if (g9 === ",") {
      if (a13.length !== 0) {
        let s12 = m5(a13, o13, i48);
        o13 = [], p12.push(s12), a13 = "", u10 += 1;
      }
    } else if (V2(g9)) {
      let s12 = false;
      if (a13.length !== 0) {
        let t13 = m5(a13, o13, i48);
        o13 = [], p12.push(t13), a13 = "", s12 = true;
      }
      T10 = F2(e3, T10);
      let h14 = e3[T10];
      if (T10 < e3.length && s12 && h14 !== "," && h14 !== ">")
        throw new r6(e3, "unexpected whitespace character");
      continue;
    } else
      a13 += g9;
    T10 += 1;
  }
  if (c14.length > 0)
    throw new r6(e3, "no matching '>' for '<'");
  switch (p12.length) {
    case 0:
      return m5(a13, o13, i48);
    case 1:
      if (a13 === "")
        return p12[0];
      throw new r6(e3, "unexpected ','");
    default:
      throw new r6(e3, "unexpected whitespace character");
  }
}
function m5(e3, n24, i48) {
  switch (e3) {
    case "&signer":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new f6(new U2());
    case "signer":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new U2();
    case "bool":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new c4();
    case "address":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new S2();
    case "u8":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new u2();
    case "u16":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new d2();
    case "u32":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new g4();
    case "u64":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new p5();
    case "u128":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new z();
    case "u256":
      if (n24.length > 0)
        throw new r6(e3, "primitive types not expected to have type arguments");
      return new T6();
    case "vector":
      if (n24.length !== 1)
        throw new r6(e3, "vector type expected to have exactly one type argument");
      return new y2(n24[0]);
    default:
      if ($2(e3)) {
        if (i48)
          return new h5(Number(e3.split("T")[1]));
        throw new r6(e3, "unexpected generic type");
      }
      if (!e3.match(/.*:.*/))
        throw new r6(e3, "unknown type");
      let c14 = e3.split("::");
      if (c14.length !== 3)
        throw new r6(e3, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      if (!N3(c14[1]))
        throw new r6(e3, "module name must only contain alphanumeric or '_' characters");
      if (!N3(c14[2]))
        throw new r6(e3, "struct name must only contain alphanumeric or '_' characters");
      return new b2(new o5(c.fromString(c14[0]), new r5(c14[1]), new r5(c14[2]), n24));
  }
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VRSUCKJA.mjs
var U3 = class i20 extends B {
  constructor(e3) {
    super();
    A(e3), this.value = e3;
  }
  serialize(e3) {
    e3.serializeBool(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(5), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i20(e3.deserializeBool());
  }
};
var p6 = class i21 extends B {
  constructor(e3) {
    super();
    w(e3, 0, t), this.value = e3;
  }
  serialize(e3) {
    e3.serializeU8(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(0), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i21(e3.deserializeU8());
  }
};
var b3 = class i22 extends B {
  constructor(e3) {
    super();
    w(e3, 0, n2), this.value = e3;
  }
  serialize(e3) {
    e3.serializeU16(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(6), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i22(e3.deserializeU16());
  }
};
var y3 = class i23 extends B {
  constructor(e3) {
    super();
    w(e3, 0, U), this.value = e3;
  }
  serialize(e3) {
    e3.serializeU32(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(7), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i23(e3.deserializeU32());
  }
};
var m6 = class i24 extends B {
  constructor(e3) {
    super();
    w(e3, BigInt(0), _), this.value = BigInt(e3);
  }
  serialize(e3) {
    e3.serializeU64(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(1), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i24(e3.deserializeU64());
  }
};
var B2 = class i25 extends B {
  constructor(e3) {
    super();
    w(e3, BigInt(0), o), this.value = BigInt(e3);
  }
  serialize(e3) {
    e3.serializeU128(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(2), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i25(e3.deserializeU128());
  }
};
var v3 = class i26 extends B {
  constructor(e3) {
    super();
    w(e3, BigInt(0), i2), this.value = BigInt(e3);
  }
  serialize(e3) {
    e3.serializeU256(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    e3.serializeU32AsUleb128(8), e3.serialize(this);
  }
  static deserialize(e3) {
    return new i26(e3.deserializeU256());
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-F7MOQC7Z.mjs
var t6 = class n6 extends B {
  constructor(e3) {
    super();
    this.values = e3;
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    if (!(this.values[0] instanceof p6) && this.values[0] !== void 0)
      throw new Error("Script function arguments only accept u8 vectors");
    e3.serializeU32AsUleb128(4), e3.serialize(this);
  }
  static U8(e3) {
    let r23;
    if (Array.isArray(e3) && typeof e3[0] == "number")
      r23 = e3;
    else if (typeof e3 == "string") {
      let i48 = i.fromHexInput(e3);
      r23 = Array.from(i48.toUint8Array());
    } else if (e3 instanceof Uint8Array)
      r23 = Array.from(e3);
    else
      throw new Error("Invalid input type");
    return new n6(r23.map((i48) => new p6(i48)));
  }
  static U16(e3) {
    return new n6(e3.map((r23) => new b3(r23)));
  }
  static U32(e3) {
    return new n6(e3.map((r23) => new y3(r23)));
  }
  static U64(e3) {
    return new n6(e3.map((r23) => new m6(r23)));
  }
  static U128(e3) {
    return new n6(e3.map((r23) => new B2(r23)));
  }
  static U256(e3) {
    return new n6(e3.map((r23) => new v3(r23)));
  }
  static Bool(e3) {
    return new n6(e3.map((r23) => new U3(r23)));
  }
  static MoveString(e3) {
    return new n6(e3.map((r23) => new a3(r23)));
  }
  serialize(e3) {
    e3.serializeVector(this.values);
  }
  static deserialize(e3, r23) {
    let i48 = e3.deserializeUleb128AsU32(), y10 = new Array();
    for (let w5 = 0; w5 < i48; w5 += 1)
      y10.push(r23.deserialize(e3));
    return new n6(y10);
  }
};
var a3 = class n7 extends B {
  constructor(e3) {
    super();
    this.value = e3;
  }
  serialize(e3) {
    e3.serializeStr(this.value);
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  serializeForScriptFunction(e3) {
    let r23 = this.bcsToBytes().slice(1);
    t6.U8(r23).serializeForScriptFunction(e3);
  }
  static deserialize(e3) {
    return new n7(e3.deserializeStr());
  }
};
var f7 = class n8 extends B {
  constructor(e3) {
    super();
    typeof e3 < "u" && e3 !== null ? this.vec = new t6([e3]) : this.vec = new t6([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(e3) {
    let r23 = this.bcsToBytes();
    e3.serializeBytes(r23);
  }
  unwrap() {
    if (this.isSome())
      return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(e3) {
    this.vec.serialize(e3);
  }
  static U8(e3) {
    return new n8(e3 != null ? new p6(e3) : void 0);
  }
  static U16(e3) {
    return new n8(e3 != null ? new b3(e3) : void 0);
  }
  static U32(e3) {
    return new n8(e3 != null ? new y3(e3) : void 0);
  }
  static U64(e3) {
    return new n8(e3 != null ? new m6(e3) : void 0);
  }
  static U128(e3) {
    return new n8(e3 != null ? new B2(e3) : void 0);
  }
  static U256(e3) {
    return new n8(e3 != null ? new v3(e3) : void 0);
  }
  static Bool(e3) {
    return new n8(e3 != null ? new U3(e3) : void 0);
  }
  static MoveString(e3) {
    return new n8(e3 != null ? new a3(e3) : void 0);
  }
  static deserialize(e3, r23) {
    let i48 = t6.deserialize(e3, r23);
    return new n8(i48.values[0]);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-B2ZKW23W.mjs
var t7 = class a4 extends B {
  constructor(e3) {
    super();
    this.value = i.fromHexInput(e3).toUint8Array();
  }
  serialize(e3) {
    e3.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(e3) {
    e3.serialize(this);
  }
  serializeForScriptFunction(e3) {
    e3.serialize(this);
  }
  static deserialize(e3, s12) {
    let o13 = e3.deserializeFixedBytes(s12);
    return new a4(o13);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RNO5ZG3C.mjs
function M(n24) {
  return typeof n24 == "boolean";
}
function D2(n24) {
  return typeof n24 == "string";
}
function N4(n24) {
  return typeof n24 == "number";
}
function P(n24) {
  return typeof n24 == "number" || typeof n24 == "bigint" || typeof n24 == "string";
}
function w4(n24) {
  return n24 == null;
}
function G4(n24) {
  return A7(n24) || x3(n24) || S4(n24) || B3(n24) || U4(n24) || I(n24) || b4(n24) || T7(n24) || E2(n24) || d3(n24) || n24 instanceof t6 || n24 instanceof f7;
}
function A7(n24) {
  return n24 instanceof U3;
}
function T7(n24) {
  return n24 instanceof c;
}
function E2(n24) {
  return n24 instanceof a3;
}
function d3(n24) {
  return n24 instanceof t7;
}
function x3(n24) {
  return n24 instanceof p6;
}
function S4(n24) {
  return n24 instanceof b3;
}
function B3(n24) {
  return n24 instanceof y3;
}
function U4(n24) {
  return n24 instanceof m6;
}
function I(n24) {
  return n24 instanceof B2;
}
function b4(n24) {
  return n24 instanceof v3;
}
function $3(n24) {
  return "bytecode" in n24;
}
function R(n24, t13) {
  throw new Error(`Type mismatch for argument ${t13}, expected '${n24}'`);
}
function W(n24) {
  let t13 = n24.params.findIndex((e3) => e3 !== "signer" && e3 !== "&signer");
  return t13 < 0 ? n24.params.length : t13;
}
function L2(n24) {
  let t13 = n24.split("::");
  if (t13.length !== 3)
    throw new Error(`Invalid function ${n24}`);
  let e3 = t13[0], F5 = t13[1], l12 = t13[2];
  return { moduleAddress: e3, moduleName: F5, functionName: l12 };
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-V6JFR2CB.mjs
var a5 = class extends B {
};
var i27 = class extends B {
};
var e = class extends B {
};

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_assert.js
function number(n24) {
  if (!Number.isSafeInteger(n24) || n24 < 0)
    throw new Error(`Wrong positive integer: ${n24}`);
}
function isBytes2(a13) {
  return a13 instanceof Uint8Array || a13 != null && typeof a13 === "object" && a13.constructor.name === "Uint8Array";
}
function bytes(b9, ...lengths) {
  if (!isBytes2(b9))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b9.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b9.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i48 = 0; i48 < pad.length; i48++)
      pad[i48] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i48 = 0; i48 < pad.length; i48++)
      pad[i48] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h14 = isLE2 ? 4 : 0;
  const l12 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h14, wh, isLE2);
  view.setUint32(byteOffset + l12, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i48 = pos; i48 < blockLen; i48++)
      buffer[i48] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i48 = 0; i48 < outLen; i48++)
      oview.setUint32(4 * i48, state[i48], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n24, le = false) {
  if (le)
    return { h: Number(n24 & U32_MASK64), l: Number(n24 >> _32n & U32_MASK64) };
  return { h: Number(n24 >> _32n & U32_MASK64) | 0, l: Number(n24 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i48 = 0; i48 < lst.length; i48++) {
    const { h: h14, l: l12 } = fromBig(lst[i48], le);
    [Ah[i48], Al[i48]] = [h14, l12];
  }
  return [Ah, Al];
}
var toBig = (h14, l12) => BigInt(h14 >>> 0) << _32n | BigInt(l12 >>> 0);
var shrSH = (h14, _l, s12) => h14 >>> s12;
var shrSL = (h14, l12, s12) => h14 << 32 - s12 | l12 >>> s12;
var rotrSH = (h14, l12, s12) => h14 >>> s12 | l12 << 32 - s12;
var rotrSL = (h14, l12, s12) => h14 << 32 - s12 | l12 >>> s12;
var rotrBH = (h14, l12, s12) => h14 << 64 - s12 | l12 >>> s12 - 32;
var rotrBL = (h14, l12, s12) => h14 >>> s12 - 32 | l12 << 64 - s12;
var rotr32H = (_h, l12) => l12;
var rotr32L = (h14, _l) => h14;
var rotlSH = (h14, l12, s12) => h14 << s12 | l12 >>> 32 - s12;
var rotlSL = (h14, l12, s12) => l12 << s12 | h14 >>> 32 - s12;
var rotlBH = (h14, l12, s12) => l12 << s12 - 32 | h14 >>> 64 - s12;
var rotlBL = (h14, l12, s12) => h14 << s12 - 32 | l12 >>> 64 - s12;
function add(Ah, Al, Bh, Bl) {
  const l12 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l12 / 2 ** 32 | 0) | 0, l: l12 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n24) => BigInt(n24))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i48 = 0; i48 < 16; i48++, offset += 4) {
      SHA512_W_H[i48] = view.getUint32(offset);
      SHA512_W_L[i48] = view.getUint32(offset += 4);
    }
    for (let i48 = 16; i48 < 80; i48++) {
      const W15h = SHA512_W_H[i48 - 15] | 0;
      const W15l = SHA512_W_L[i48 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i48 - 2] | 0;
      const W2l = SHA512_W_L[i48 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i48 - 7], SHA512_W_L[i48 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i48 - 7], SHA512_W_H[i48 - 16]);
      SHA512_W_H[i48] = SUMh | 0;
      SHA512_W_L[i48] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i48 = 0; i48 < 80; i48++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i48], SHA512_W_L[i48]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i48], SHA512_W_H[i48]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c14, dkLen, asyncTick } = opts;
  number(c14);
  number(dkLen);
  number(asyncTick);
  if (c14 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt2 = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt2);
  return { c: c14, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u10) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u10.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt2, opts) {
  const { c: c14, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u10 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u10);
    Ti.set(u10.subarray(0, Ti.length));
    for (let ui = 1; ui < c14; ui++) {
      PRF._cloneInto(prfW).update(u10).digestInto(u10);
      for (let i48 = 0; i48 < Ti.length; i48++)
        Ti[i48] ^= u10[i48];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u10);
}

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a13, b9, c14) => a13 & b9 ^ ~a13 & c14;
var Maj = (a13, b9, c14) => a13 & b9 ^ a13 & c14 ^ b9 & c14;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A13, B: B5, C: C6, D: D8, E: E6, F: F5, G: G9, H: H3 } = this;
    return [A13, B5, C6, D8, E6, F5, G9, H3];
  }
  // prettier-ignore
  set(A13, B5, C6, D8, E6, F5, G9, H3) {
    this.A = A13 | 0;
    this.B = B5 | 0;
    this.C = C6 | 0;
    this.D = D8 | 0;
    this.E = E6 | 0;
    this.F = F5 | 0;
    this.G = G9 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i48 = 0; i48 < 16; i48++, offset += 4)
      SHA256_W[i48] = view.getUint32(offset, false);
    for (let i48 = 16; i48 < 64; i48++) {
      const W15 = SHA256_W[i48 - 15];
      const W22 = SHA256_W[i48 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i48] = s1 + SHA256_W[i48 - 7] + s0 + SHA256_W[i48 - 16] | 0;
    }
    let { A: A13, B: B5, C: C6, D: D8, E: E6, F: F5, G: G9, H: H3 } = this;
    for (let i48 = 0; i48 < 64; i48++) {
      const sigma1 = rotr(E6, 6) ^ rotr(E6, 11) ^ rotr(E6, 25);
      const T1 = H3 + sigma1 + Chi(E6, F5, G9) + SHA256_K[i48] + SHA256_W[i48] | 0;
      const sigma0 = rotr(A13, 2) ^ rotr(A13, 13) ^ rotr(A13, 22);
      const T22 = sigma0 + Maj(A13, B5, C6) | 0;
      H3 = G9;
      G9 = F5;
      F5 = E6;
      E6 = D8 + T1 | 0;
      D8 = C6;
      C6 = B5;
      B5 = A13;
      A13 = T1 + T22 | 0;
    }
    A13 = A13 + this.A | 0;
    B5 = B5 + this.B | 0;
    C6 = C6 + this.C | 0;
    D8 = D8 + this.D | 0;
    E6 = E6 + this.E | 0;
    F5 = F5 + this.F | 0;
    G9 = G9 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A13, B5, C6, D8, E6, F5, G9, H3);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/.pnpm/@scure+base@1.1.5/node_modules/@scure/base/lib/esm/index.js
function assertNumber(n24) {
  if (!Number.isSafeInteger(n24))
    throw new Error(`Wrong integer: ${n24}`);
}
function isBytes3(a13) {
  return a13 instanceof Uint8Array || a13 != null && typeof a13 === "object" && a13.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id = (a13) => a13;
  const wrap = (a13, b9) => (c14) => a13(b9(c14));
  const encode3 = args.map((x8) => x8.encode).reduceRight(wrap, id);
  const decode = args.map((x8) => x8.decode).reduce(wrap, id);
  return { encode: encode3, decode };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i48) => {
        assertNumber(i48);
        if (i48 < 0 || i48 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i48} (alphabet: ${alphabet2.length})`);
        return alphabet2[i48];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i48 of from)
        if (typeof i48 !== "string")
          throw new Error(`join.encode: non-string input=${i48}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i48 of data)
        if (typeof i48 !== "string")
          throw new Error(`padding.encode: non-string input=${i48}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i48 of input)
        if (typeof i48 !== "string")
          throw new Error(`padding.decode: non-string input=${i48}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d9) => {
    assertNumber(d9);
    if (d9 < 0 || d9 >= from)
      throw new Error(`Wrong integer: ${d9}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i48 = pos; i48 < digits.length; i48++) {
      const digit = digits[i48];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i48] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i48;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i48 = 0; i48 < data.length - 1 && data[i48] === 0; i48++)
    res.push(0);
  return res.reverse();
}
var gcd = (a13, b9) => !b9 ? a13 : gcd(b9, a13 % b9);
var radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n24 of data) {
    assertNumber(n24);
    if (n24 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n24} from=${from}`);
    carry = carry << from | n24;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes2) => {
      if (!isBytes3(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes3(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e3) {
    }
  };
}
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes3(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i48 = 0; i48 < len; i48++)
        if (newChecksum[i48] !== oldChecksum[i48])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s12) => s12.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b9 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i48 = 0; i48 < POLYMOD_GENERATORS.length; i48++) {
    if ((b9 >> i48 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i48];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i48 = 0; i48 < len; i48++) {
    const c14 = prefix.charCodeAt(i48);
    if (c14 < 33 || c14 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c14 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i48 = 0; i48 < len; i48++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i48) & 31;
  for (let v9 of words)
    chk = bech32Polymod(chk) ^ v9;
  for (let i48 = 0; i48 < 6; i48++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode3(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode3, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s12) => {
  if (typeof s12 !== "string" || s12.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s12} with length ${s12.length}`);
  return s12.toLowerCase();
}));

// node_modules/.pnpm/@scure+bip39@1.2.2/node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LR65XHSF.mjs
var d4 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var m7 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var y4 = ((t13) => (t13.ED25519 = "ed25519 seed", t13))(y4 || {});
var g5 = 2147483648;
function D3(e3) {
  return m7.test(e3);
}
function E3(e3) {
  return d4.test(e3);
}
var A8 = (e3, t13) => {
  let r23 = hmac.create(sha512, e3).update(t13).digest();
  return { key: r23.slice(0, 32), chainCode: r23.slice(32) };
};
var f8 = ({ key: e3, chainCode: t13 }, r23) => {
  let n24 = new ArrayBuffer(4);
  new DataView(n24).setUint32(0, r23);
  let o13 = new Uint8Array(n24), s12 = new Uint8Array([0]), a13 = new Uint8Array([...s12, ...e3, ...o13]);
  return A8(t13, a13);
};
var x4 = (e3) => e3.replace("'", "");
var U5 = (e3) => e3.split("/").slice(1).map(x4);
var h6 = (e3) => {
  let t13 = e3.trim().split(/\s+/).map((r23) => r23.toLowerCase()).join(" ");
  return mnemonicToSeedSync(t13);
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZFIMVSCR.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var i28 = class i29 extends a5 {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== i29.LENGTH)
      throw new Error(`PublicKey length should be ${i29.LENGTH}`);
    this.key = t13;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(e3) {
    let { message: t13, signature: a13 } = e3, y10 = i.fromHexInput(t13).toUint8Array(), c14 = a13.toUint8Array();
    return import_tweetnacl.default.sign.detached.verify(y10, c14, this.key.toUint8Array());
  }
  serialize(e3) {
    e3.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new i29(t13);
  }
  static load(e3) {
    let t13 = e3.deserializeBytes();
    return new i29(t13);
  }
  static isPublicKey(e3) {
    return e3 instanceof i29;
  }
};
i28.LENGTH = 32;
var l5 = i28;
var r7 = class r8 extends i27 {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== r8.LENGTH)
      throw new Error(`PrivateKey length should be ${r8.LENGTH}`);
    this.signingKeyPair = import_tweetnacl.default.sign.keyPair.fromSeed(t13.toUint8Array().slice(0, r8.LENGTH));
  }
  toUint8Array() {
    return this.signingKeyPair.secretKey.slice(0, r8.LENGTH);
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  sign(e3) {
    let t13 = i.fromHexInput(e3), a13 = import_tweetnacl.default.sign.detached(t13.toUint8Array(), this.signingKeyPair.secretKey);
    return new d5(a13);
  }
  serialize(e3) {
    e3.serializeBytes(this.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new r8(t13);
  }
  static generate() {
    let e3 = import_tweetnacl.default.sign.keyPair();
    return new r8(e3.secretKey.slice(0, r8.LENGTH));
  }
  publicKey() {
    let e3 = this.signingKeyPair.publicKey;
    return new l5(e3);
  }
  static fromDerivationPath(e3, t13) {
    if (!E3(e3))
      throw new Error(`Invalid derivation path ${e3}`);
    return r8.fromDerivationPathInner(e3, h6(t13));
  }
  static fromDerivationPathInner(e3, t13, a13 = g5) {
    let { key: y10, chainCode: c14 } = A8(r8.SLIP_0010_SEED, t13), x8 = U5(e3).map((u10) => parseInt(u10, 10)), { key: z4 } = x8.reduce((u10, A13) => f8(u10, A13 + a13), { key: y10, chainCode: c14 });
    return new r8(z4);
  }
  static isPrivateKey(e3) {
    return e3 instanceof r8;
  }
};
r7.LENGTH = 32, r7.SLIP_0010_SEED = "ed25519 seed";
var v4 = r7;
var n9 = class n10 extends e {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== n10.LENGTH)
      throw new Error(`Signature length should be ${n10.LENGTH}`);
    this.data = t13;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(e3) {
    e3.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new n10(t13);
  }
  static load(e3) {
    let t13 = e3.deserializeBytes();
    return new n10(t13);
  }
  static isSignature(e3) {
    return e3 instanceof n10;
  }
};
n9.LENGTH = 64;
var d5 = n9;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7IGH7N52.mjs
var i30 = class i31 extends a5 {
  constructor(e3) {
    super();
    let { publicKeys: t13, threshold: r23 } = e3;
    if (t13.length > i31.MAX_KEYS || t13.length < i31.MIN_KEYS)
      throw new Error(`Must have between ${i31.MIN_KEYS} and ${i31.MAX_KEYS} public keys, inclusive`);
    if (r23 < i31.MIN_THRESHOLD || r23 > t13.length)
      throw new Error(`Threshold must be between ${i31.MIN_THRESHOLD} and ${t13.length}, inclusive`);
    this.publicKeys = t13, this.threshold = r23;
  }
  toUint8Array() {
    let e3 = new Uint8Array(this.publicKeys.length * l5.LENGTH + 1);
    return this.publicKeys.forEach((t13, r23) => {
      e3.set(t13.toUint8Array(), r23 * l5.LENGTH);
    }), e3[this.publicKeys.length * l5.LENGTH] = this.threshold, e3;
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(e3) {
    throw new Error("TODO - Method not implemented.");
  }
  serialize(e3) {
    e3.serializeBytes(this.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes(), r23 = t13[t13.length - 1], o13 = [];
    for (let a13 = 0; a13 < t13.length - 1; a13 += l5.LENGTH) {
      let s12 = a13;
      o13.push(new l5(t13.subarray(s12, s12 + l5.LENGTH)));
    }
    return new i31({ publicKeys: o13, threshold: r23 });
  }
};
i30.MAX_KEYS = 32, i30.MIN_KEYS = 2, i30.MIN_THRESHOLD = 1;
var g6 = i30;
var n11 = class n12 extends e {
  constructor(e3) {
    super();
    let { signatures: t13, bitmap: r23 } = e3;
    if (r23.length !== n12.BITMAP_LEN)
      throw new Error(`"bitmap" length should be ${n12.BITMAP_LEN}`);
    if (t13.length > n12.MAX_SIGNATURES_SUPPORTED)
      throw new Error(`The number of signatures cannot be greater than ${n12.MAX_SIGNATURES_SUPPORTED}`);
    this.signatures = t13, this.bitmap = r23;
  }
  toUint8Array() {
    let e3 = new Uint8Array(this.signatures.length * d5.LENGTH + n12.BITMAP_LEN);
    return this.signatures.forEach((t13, r23) => {
      e3.set(t13.toUint8Array(), r23 * d5.LENGTH);
    }), e3.set(this.bitmap, this.signatures.length * d5.LENGTH), e3;
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  static createBitmap(e3) {
    let { bits: t13 } = e3, r23 = 128, o13 = new Uint8Array([0, 0, 0, 0]), a13 = /* @__PURE__ */ new Set();
    return t13.forEach((s12) => {
      if (s12 >= n12.MAX_SIGNATURES_SUPPORTED)
        throw new Error(`Cannot have a signature larger than ${n12.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (a13.has(s12))
        throw new Error("Duplicate bits detected.");
      a13.add(s12);
      let c14 = Math.floor(s12 / 8), y10 = o13[c14];
      y10 |= r23 >> s12 % 8, o13[c14] = y10;
    }), o13;
  }
  serialize(e3) {
    e3.serializeBytes(this.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes(), r23 = t13.subarray(t13.length - 4), o13 = [];
    for (let a13 = 0; a13 < t13.length - r23.length; a13 += d5.LENGTH) {
      let s12 = a13;
      o13.push(new d5(t13.subarray(s12, s12 + d5.LENGTH)));
    }
    return new n12({ signatures: o13, bitmap: r23 });
  }
};
n11.MAX_SIGNATURES_SUPPORTED = 32, n11.BITMAP_LEN = 4;
var p7 = n11;

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R4 = _1n, x8 = 1, y10 = 0; round < 24; round++) {
  [x8, y10] = [y10, (2 * x8 + 3 * y10) % 5];
  SHA3_PI.push(2 * (5 * y10 + x8));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t13 = _0n;
  for (let j4 = 0; j4 < 7; j4++) {
    R4 = (R4 << _1n ^ (R4 >> _7n) * _0x71n) % _256n;
    if (R4 & _2n)
      t13 ^= _1n << (_1n << BigInt(j4)) - _1n;
  }
  _SHA3_IOTA.push(t13);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h14, l12, s12) => s12 > 32 ? rotlBH(h14, l12, s12) : rotlSH(h14, l12, s12);
var rotlL = (h14, l12, s12) => s12 > 32 ? rotlBL(h14, l12, s12) : rotlSL(h14, l12, s12);
function keccakP(s12, rounds = 24) {
  const B5 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x8 = 0; x8 < 10; x8++)
      B5[x8] = s12[x8] ^ s12[x8 + 10] ^ s12[x8 + 20] ^ s12[x8 + 30] ^ s12[x8 + 40];
    for (let x8 = 0; x8 < 10; x8 += 2) {
      const idx1 = (x8 + 8) % 10;
      const idx0 = (x8 + 2) % 10;
      const B0 = B5[idx0];
      const B1 = B5[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B5[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B5[idx1 + 1];
      for (let y10 = 0; y10 < 50; y10 += 10) {
        s12[x8 + y10] ^= Th;
        s12[x8 + y10 + 1] ^= Tl;
      }
    }
    let curH = s12[2];
    let curL = s12[3];
    for (let t13 = 0; t13 < 24; t13++) {
      const shift = SHA3_ROTL[t13];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t13];
      curH = s12[PI];
      curL = s12[PI + 1];
      s12[PI] = Th;
      s12[PI + 1] = Tl;
    }
    for (let y10 = 0; y10 < 50; y10 += 10) {
      for (let x8 = 0; x8 < 10; x8++)
        B5[x8] = s12[y10 + x8];
      for (let x8 = 0; x8 < 10; x8++)
        s12[y10 + x8] ^= ~B5[(x8 + 2) % 10] & B5[(x8 + 4) % 10];
    }
    s12[0] ^= SHA3_IOTA_H[round];
    s12[1] ^= SHA3_IOTA_L[round];
  }
  B5.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i48 = 0; i48 < take; i48++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes4,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
function isBytes4(a13) {
  return a13 instanceof Uint8Array || a13 != null && typeof a13 === "object" && a13.constructor.name === "Uint8Array";
}
var hexes2 = Array.from({ length: 256 }, (_5, i48) => i48.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  if (!isBytes4(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i48 = 0; i48 < bytes2.length; i48++) {
    hex2 += hexes2[bytes2[i48]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase162(char) {
  if (char >= asciis2._0 && char <= asciis2._9)
    return char - asciis2._0;
  if (char >= asciis2._A && char <= asciis2._F)
    return char - (asciis2._A - 10);
  if (char >= asciis2._a && char <= asciis2._f)
    return char - (asciis2._a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi));
    const n24 = asciiToBase162(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n24 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n24;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!isBytes4(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n24, len) {
  return hexToBytes2(n24.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n24, len) {
  return numberToBytesBE(n24, len).reverse();
}
function numberToVarBytesBE(n24) {
  return hexToBytes2(numberToHexUnpadded(n24));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e3) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e3}`);
    }
  } else if (isBytes4(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i48 = 0; i48 < arrays.length; i48++) {
    const a13 = arrays[i48];
    if (!isBytes4(a13))
      throw new Error("Uint8Array expected");
    sum += a13.length;
  }
  let res = new Uint8Array(sum);
  let pad = 0;
  for (let i48 = 0; i48 < arrays.length; i48++) {
    const a13 = arrays[i48];
    res.set(a13, pad);
    pad += a13.length;
  }
  return res;
}
function equalBytes(a13, b9) {
  if (a13.length !== b9.length)
    return false;
  let diff = 0;
  for (let i48 = 0; i48 < a13.length; i48++)
    diff |= a13[i48] ^ b9[i48];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n24) {
  let len;
  for (len = 0; n24 > _0n2; n24 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n24, pos) {
  return n24 >> BigInt(pos) & _1n2;
}
var bitSet = (n24, pos, value) => {
  return n24 | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n24) => (_2n2 << BigInt(n24 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v9 = u8n(hashLen);
  let k3 = u8n(hashLen);
  let i48 = 0;
  const reset = () => {
    v9.fill(1);
    k3.fill(0);
    i48 = 0;
  };
  const h14 = (...b9) => hmacFn(k3, v9, ...b9);
  const reseed = (seed = u8n()) => {
    k3 = h14(u8fr([0]), seed);
    v9 = h14();
    if (seed.length === 0)
      return;
    k3 = h14(u8fr([1]), seed);
    v9 = h14();
  };
  const gen2 = () => {
    if (i48++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v9 = h14();
      const sl = v9.slice();
      out.push(sl);
      len += v9.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes4(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a13, b9) {
  const result = a13 % b9;
  return result >= _0n3 ? result : b9 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x8, power, modulo) {
  let res = x8;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a13 = mod(number2, modulo);
  let b9 = modulo;
  let x8 = _0n3, y10 = _1n3, u10 = _1n3, v9 = _0n3;
  while (a13 !== _0n3) {
    const q4 = b9 / a13;
    const r23 = b9 % a13;
    const m12 = x8 - u10 * q4;
    const n24 = y10 - v9 * q4;
    b9 = a13, a13 = r23, x8 = u10, y10 = v9, u10 = m12, v9 = n24;
  }
  const gcd2 = b9;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x8, modulo);
}
function tonelliShanks(P6) {
  const legendreC = (P6 - _1n3) / _2n3;
  let Q4, S8, Z5;
  for (Q4 = P6 - _1n3, S8 = 0; Q4 % _2n3 === _0n3; Q4 /= _2n3, S8++)
    ;
  for (Z5 = _2n3; Z5 < P6 && pow(Z5, legendreC, P6) !== P6 - _1n3; Z5++)
    ;
  if (S8 === 1) {
    const p1div4 = (P6 + _1n3) / _4n;
    return function tonelliFast(Fp2, n24) {
      const root = Fp2.pow(n24, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q4 + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n24) {
    if (Fp2.pow(n24, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r23 = S8;
    let g9 = Fp2.pow(Fp2.mul(Fp2.ONE, Z5), Q4);
    let x8 = Fp2.pow(n24, Q1div2);
    let b9 = Fp2.pow(n24, Q4);
    while (!Fp2.eql(b9, Fp2.ONE)) {
      if (Fp2.eql(b9, Fp2.ZERO))
        return Fp2.ZERO;
      let m12 = 1;
      for (let t22 = Fp2.sqr(b9); m12 < r23; m12++) {
        if (Fp2.eql(t22, Fp2.ONE))
          break;
        t22 = Fp2.sqr(t22);
      }
      const ge2 = Fp2.pow(g9, _1n3 << BigInt(r23 - m12 - 1));
      g9 = Fp2.sqr(ge2);
      x8 = Fp2.mul(x8, ge2);
      b9 = Fp2.mul(b9, g9);
      r23 = m12;
    }
    return x8;
  };
}
function FpSqrt(P6) {
  if (P6 % _4n === _3n) {
    const p1div4 = (P6 + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n24) {
      const root = Fp2.pow(n24, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P6 % _8n === _5n) {
    const c1 = (P6 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n24) {
      const n25 = Fp2.mul(n24, _2n3);
      const v9 = Fp2.pow(n25, c1);
      const nv = Fp2.mul(n24, v9);
      const i48 = Fp2.mul(Fp2.mul(nv, _2n3), v9);
      const root = Fp2.mul(nv, Fp2.sub(i48, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P6 % _16n === _9n) {
  }
  return tonelliShanks(P6);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f13, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f13.ONE;
  if (power === _1n3)
    return num;
  let p12 = f13.ONE;
  let d9 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p12 = f13.mul(p12, d9);
    d9 = f13.sqr(d9);
    power >>= _1n3;
  }
  return p12;
}
function FpInvertBatch(f13, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i48) => {
    if (f13.is0(num))
      return acc;
    tmp[i48] = acc;
    return f13.mul(acc, num);
  }, f13.ONE);
  const inverted = f13.inv(lastMultiplied);
  nums.reduceRight((acc, num, i48) => {
    if (f13.is0(num))
      return acc;
    tmp[i48] = f13.mul(acc, tmp[i48]);
    return f13.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n24, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n24.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f13 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f13, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n24) => sqrtP(f13, n24)),
    invertBatch: (lst) => FpInvertBatch(f13, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a13, b9, c14) => c14 ? b9 : a13,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f13);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c14, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W5) => {
    const windows = Math.ceil(bits / W5) + 1;
    const windowSize = 2 ** (W5 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n24) {
      let p12 = c14.ZERO;
      let d9 = elm;
      while (n24 > _0n4) {
        if (n24 & _1n4)
          p12 = p12.add(d9);
        d9 = d9.double();
        n24 >>= _1n4;
      }
      return p12;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W5) {
      const { windows, windowSize } = opts(W5);
      const points = [];
      let p12 = elm;
      let base = p12;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p12;
        points.push(base);
        for (let i48 = 1; i48 < windowSize; i48++) {
          base = base.add(p12);
          points.push(base);
        }
        p12 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W5, precomputes, n24) {
      const { windows, windowSize } = opts(W5);
      let p12 = c14.ZERO;
      let f13 = c14.BASE;
      const mask = BigInt(2 ** W5 - 1);
      const maxNumber = 2 ** W5;
      const shiftBy = BigInt(W5);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n24 & mask);
        n24 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n24 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f13 = f13.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p12 = p12.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p12, f: f13 };
    },
    wNAFCached(P6, precomputesMap, n24, transform) {
      const W5 = P6._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P6);
      if (!comp) {
        comp = this.precomputeWindow(P6, W5);
        if (W5 !== 1) {
          precomputesMap.set(P6, transform(comp));
        }
      }
      return this.wNAF(W5, comp, n24);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a13 } = opts;
  if (endo) {
    if (!Fp2.eql(a13, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m12 = "") {
      super(m12);
    }
  },
  _parseInt(data) {
    const { Err: E6 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E6("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E6("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E6("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E6("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E6 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!isBytes4(data))
      throw new Error("ui8a expected");
    let l12 = data.length;
    if (l12 < 2 || data[0] != 48)
      throw new E6("Invalid signature tag");
    if (data[1] !== l12 - 2)
      throw new E6("Invalid signature: incorrect length");
    const { d: r23, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s12, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E6("Invalid signature: left bytes after parsing");
    return { r: r23, s: s12 };
  },
  hexFromSig(sig) {
    const slice = (s13) => Number.parseInt(s13[0], 16) & 8 ? "00" + s13 : s13;
    const h14 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s12 = slice(h14(sig.s));
    const r23 = slice(h14(sig.r));
    const shl = s12.length / 2;
    const rhl = r23.length / 2;
    const sl = h14(shl);
    const rl = h14(rhl);
    return `30${h14(rhl + shl + 4)}02${rl}${r23}02${sl}${s12}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a13 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a13.x), Fp2.toBytes(a13.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x8 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y10 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x8, y: y10 };
  });
  function weierstrassEquation(x8) {
    const { a: a13, b: b9 } = CURVE;
    const x22 = Fp2.sqr(x8);
    const x32 = Fp2.mul(x22, x8);
    return Fp2.add(Fp2.add(x32, Fp2.mul(x8, a13)), b9);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n24 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes4(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n24);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p12) {
      const { x: x8, y: y10 } = p12 || {};
      if (!p12 || !Fp2.isValid(x8) || !Fp2.isValid(y10))
        throw new Error("invalid affine point");
      if (p12 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i48) => Fp2.eql(i48, Fp2.ZERO);
      if (is0(x8) && is0(y10))
        return Point3.ZERO;
      return new Point3(x8, y10, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p12) => p12.pz));
      return points.map((p12, i48) => p12.toAffine(toInv[i48])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P6 = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P6.assertValidity();
      return P6;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x8, y: y10 } = this.toAffine();
      if (!Fp2.isValid(x8) || !Fp2.isValid(y10))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y10);
      const right = weierstrassEquation(x8);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y10 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y10);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X22, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a13, b: b9 } = CURVE;
      const b32 = Fp2.mul(b9, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp2.ZERO, Y3 = Fp2.ZERO, Z32 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t22 = Fp2.mul(Z1, Z1);
      let t32 = Fp2.mul(X1, Y1);
      t32 = Fp2.add(t32, t32);
      Z32 = Fp2.mul(X1, Z1);
      Z32 = Fp2.add(Z32, Z32);
      X32 = Fp2.mul(a13, Z32);
      Y3 = Fp2.mul(b32, t22);
      Y3 = Fp2.add(X32, Y3);
      X32 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X32, Y3);
      X32 = Fp2.mul(t32, X32);
      Z32 = Fp2.mul(b32, Z32);
      t22 = Fp2.mul(a13, t22);
      t32 = Fp2.sub(t0, t22);
      t32 = Fp2.mul(a13, t32);
      t32 = Fp2.add(t32, Z32);
      Z32 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z32, t0);
      t0 = Fp2.add(t0, t22);
      t0 = Fp2.mul(t0, t32);
      Y3 = Fp2.add(Y3, t0);
      t22 = Fp2.mul(Y1, Z1);
      t22 = Fp2.add(t22, t22);
      t0 = Fp2.mul(t22, t32);
      X32 = Fp2.sub(X32, t0);
      Z32 = Fp2.mul(t22, t1);
      Z32 = Fp2.add(Z32, Z32);
      Z32 = Fp2.add(Z32, Z32);
      return new Point3(X32, Y3, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp2.ZERO, Y3 = Fp2.ZERO, Z32 = Fp2.ZERO;
      const a13 = CURVE.a;
      const b32 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X22);
      let t1 = Fp2.mul(Y1, Y22);
      let t22 = Fp2.mul(Z1, Z22);
      let t32 = Fp2.add(X1, Y1);
      let t42 = Fp2.add(X22, Y22);
      t32 = Fp2.mul(t32, t42);
      t42 = Fp2.add(t0, t1);
      t32 = Fp2.sub(t32, t42);
      t42 = Fp2.add(X1, Z1);
      let t52 = Fp2.add(X22, Z22);
      t42 = Fp2.mul(t42, t52);
      t52 = Fp2.add(t0, t22);
      t42 = Fp2.sub(t42, t52);
      t52 = Fp2.add(Y1, Z1);
      X32 = Fp2.add(Y22, Z22);
      t52 = Fp2.mul(t52, X32);
      X32 = Fp2.add(t1, t22);
      t52 = Fp2.sub(t52, X32);
      Z32 = Fp2.mul(a13, t42);
      X32 = Fp2.mul(b32, t22);
      Z32 = Fp2.add(X32, Z32);
      X32 = Fp2.sub(t1, Z32);
      Z32 = Fp2.add(t1, Z32);
      Y3 = Fp2.mul(X32, Z32);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t22 = Fp2.mul(a13, t22);
      t42 = Fp2.mul(b32, t42);
      t1 = Fp2.add(t1, t22);
      t22 = Fp2.sub(t0, t22);
      t22 = Fp2.mul(a13, t22);
      t42 = Fp2.add(t42, t22);
      t0 = Fp2.mul(t1, t42);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t52, t42);
      X32 = Fp2.mul(t32, X32);
      X32 = Fp2.sub(X32, t0);
      t0 = Fp2.mul(t32, t1);
      Z32 = Fp2.mul(t52, Z32);
      Z32 = Fp2.add(Z32, t0);
      return new Point3(X32, Y3, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n24) {
      return wnaf.wNAFCached(this, pointPrecomputes, n24, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p12) => p12.pz));
        return comp.map((p12, i48) => p12.toAffine(toInv[i48])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n24) {
      const I5 = Point3.ZERO;
      if (n24 === _0n5)
        return I5;
      assertGE(n24);
      if (n24 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n24);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n24);
      let k1p = I5;
      let k2p = I5;
      let d9 = this;
      while (k1 > _0n5 || k22 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d9);
        if (k22 & _1n5)
          k2p = k2p.add(d9);
        d9 = d9.double();
        k1 >>= _1n5;
        k22 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n24 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n24);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p12, f: f13 } = this.wNAF(n24);
        point = p12;
        fake = f13;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q4, a13, b9) {
      const G9 = Point3.BASE;
      const mul = (P6, a14) => a14 === _0n5 || a14 === _1n5 || !P6.equals(G9) ? P6.multiplyUnsafe(a14) : P6.multiply(a14);
      const sum = mul(this, a13).add(mul(Q4, b9));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x8, py: y10, pz: z4 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z4);
      const ax = Fp2.mul(x8, iz);
      const ay = Fp2.mul(y10, iz);
      const zz = Fp2.mul(z4, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN2(a13) {
    return mod(a13, CURVE_ORDER);
  }
  function invN(a13) {
    return invert(a13, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a13 = point.toAffine();
      const x8 = Fp2.toBytes(a13.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x8);
      } else {
        return cat(Uint8Array.from([4]), x8, Fp2.toBytes(a13.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x8 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x8))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x8);
        let y10 = Fp2.sqrt(y22);
        const isYOdd = (y10 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y10 = Fp2.neg(y10);
        return { x: x8, y: y10 };
      } else if (len === uncompressedLen && head === 4) {
        const x8 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y10 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x8, y: y10 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s12) {
    return isBiggerThanHalfOrder(s12) ? modN2(-s12) : s12;
  }
  const slcNum = (b9, from, to) => bytesToNumberBE(b9.slice(from, to));
  class Signature {
    constructor(r23, s12, recovery) {
      this.r = r23;
      this.s = s12;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l12 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l12 * 2);
      return new Signature(slcNum(hex2, 0, l12), slcNum(hex2, l12, 2 * l12));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r23, s: s12 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r23, s12);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r23, s: s12, recovery: rec } = this;
      const h14 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r23 + CURVE.n : r23;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R4 = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h14 * ir);
      const u22 = modN2(s12 * ir);
      const Q4 = Point3.BASE.multiplyAndAddUnsafe(R4, u1, u22);
      if (!Q4)
        throw new Error("point at infinify");
      Q4.assertValidity();
      return Q4;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes4(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b9 = Point3.fromHex(publicB);
    return b9.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k3) => k3 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d9 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d9), int2octets(h1int)];
    if (ent != null) {
      const e3 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes2(...seedArgs);
    const m12 = h1int;
    function k2sig(kBytes) {
      const k3 = bits2int(kBytes);
      if (!isWithinCurveOrder(k3))
        return;
      const ik = invN(k3);
      const q4 = Point3.BASE.multiply(k3).toAffine();
      const r23 = modN2(q4.x);
      if (r23 === _0n5)
        return;
      const s12 = modN2(ik * modN2(m12 + r23 * d9));
      if (s12 === _0n5)
        return;
      let recovery = (q4.x === r23 ? 0 : 2) | Number(q4.y & _1n5);
      let normS = s12;
      if (lowS && isBiggerThanHalfOrder(s12)) {
        normS = normalizeS(s12);
        recovery ^= 1;
      }
      return new Signature(r23, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C6 = CURVE;
    const drbg = createHmacDrbg(C6.hash.outputLen, C6.nByteLength, C6.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P6;
    try {
      if (typeof sg === "string" || isBytes4(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r24, s: s13 } = sg;
        _sig = new Signature(r24, s13);
      } else {
        throw new Error("PARSE");
      }
      P6 = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r23, s: s12 } = _sig;
    const h14 = bits2int_modN(msgHash);
    const is = invN(s12);
    const u1 = modN2(h14 * is);
    const u22 = modN2(r23 * is);
    const R4 = (_a = Point3.BASE.multiplyAndAddUnsafe(P6, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R4)
      return false;
    const v9 = modN2(R4.x);
    return v9 === r23;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp2, Z5) {
  const q4 = Fp2.ORDER;
  let l12 = _0n5;
  for (let o13 = q4 - _1n5; o13 % _2n4 === _0n5; o13 /= _2n4)
    l12 += _1n5;
  const c1 = l12;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c22 = (q4 - _1n5) / _2n_pow_c1;
  const c32 = (c22 - _1n5) / _2n4;
  const c42 = _2n_pow_c1 - _1n5;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp2.pow(Z5, c22);
  const c72 = Fp2.pow(Z5, (c22 + _1n5) / _2n4);
  let sqrtRatio = (u10, v9) => {
    let tv1 = c62;
    let tv2 = Fp2.pow(v9, c42);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v9);
    let tv5 = Fp2.mul(u10, tv3);
    tv5 = Fp2.pow(tv5, c32);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v9);
    tv3 = Fp2.mul(tv5, u10);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c52);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c72);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i48 = c1; i48 > _1n5; i48--) {
      let tv52 = i48 - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c14 = (Fp2.ORDER - _3n2) / _4n2;
    const c23 = Fp2.sqrt(Fp2.neg(Z5));
    sqrtRatio = (u10, v9) => {
      let tv1 = Fp2.sqr(v9);
      const tv2 = Fp2.mul(u10, v9);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c14);
      y1 = Fp2.mul(y1, tv2);
      const y22 = Fp2.mul(y1, c23);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v9);
      const isQR = Fp2.eql(tv3, u10);
      let y10 = Fp2.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y10 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u10) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x8, y10;
    tv1 = Fp2.sqr(u10);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x8 = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y10 = Fp2.mul(tv1, u10);
    y10 = Fp2.mul(y10, value);
    x8 = Fp2.cmov(x8, tv3, isValid);
    y10 = Fp2.cmov(y10, value, isValid);
    const e1 = Fp2.isOdd(u10) === Fp2.isOdd(y10);
    y10 = Fp2.cmov(Fp2.neg(y10), y10, e1);
    x8 = Fp2.div(x8, tv4);
    return { x: x8, y: y10 };
  };
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (isBytes4(dst))
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i48 = length - 1; i48 >= 0; i48--) {
    res[i48] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a13, b9) {
  const arr = new Uint8Array(a13.length);
  for (let i48 = 0; i48 < a13.length; i48++) {
    arr[i48] = a13[i48] ^ b9[i48];
  }
  return arr;
}
function abytes(item) {
  if (!isBytes4(item))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H3) {
  abytes(msg);
  abytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H3(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b9 = new Array(ell);
  const b_0 = H3(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b9[0] = H3(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i48 = 1; i48 <= ell; i48++) {
    const args = [strxor(b_0, b9[i48 - 1]), i2osp(i48 + 1, 1), DST_prime];
    b9[i48] = H3(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b9);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k3, H3) {
  abytes(msg);
  abytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k3 / 8);
    DST = H3.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p12, k: k3, m: m12, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p12.toString(2).length;
  const L4 = Math.ceil((log2p + k3) / 8);
  const len_in_bytes = count * m12 * L4;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k3, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u10 = new Array(count);
  for (let i48 = 0; i48 < count; i48++) {
    const e3 = new Array(m12);
    for (let j4 = 0; j4 < m12; j4++) {
      const elm_offset = L4 * (j4 + i48 * m12);
      const tv = prb.subarray(elm_offset, elm_offset + L4);
      e3[j4] = mod(os2ip(tv), p12);
    }
    u10[i48] = e3;
  }
  return u10;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i48) => Array.from(i48).reverse());
  return (x8, y10) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i48) => field.add(field.mul(acc, x8), i48)));
    x8 = field.div(xNum, xDen);
    y10 = field.mul(y10, field.div(yNum, yDen));
    return { x: x8, y: y10 };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u10 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u10[0]));
      const u1 = Point3.fromAffine(mapToCurve(u10[1]));
      const P6 = u0.add(u1).clearCofactor();
      P6.assertValidity();
      return P6;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u10 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P6 = Point3.fromAffine(mapToCurve(u10[0])).clearCofactor();
      P6.assertValidity();
      return P6;
    }
  };
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/.pnpm/@noble+curves@1.3.0/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a13, b9) => (a13 + b9 / _2n5) / b9;
function sqrtMod(y10) {
  const P6 = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y10 * y10 * y10 % P6;
  const b32 = b22 * b22 * y10 % P6;
  const b62 = pow2(b32, _3n3, P6) * b32 % P6;
  const b9 = pow2(b62, _3n3, P6) * b32 % P6;
  const b11 = pow2(b9, _2n5, P6) * b22 % P6;
  const b222 = pow2(b11, _11n, P6) * b11 % P6;
  const b44 = pow2(b222, _22n, P6) * b222 % P6;
  const b88 = pow2(b44, _44n, P6) * b44 % P6;
  const b176 = pow2(b88, _88n, P6) * b88 % P6;
  const b220 = pow2(b176, _44n, P6) * b44 % P6;
  const b223 = pow2(b220, _3n3, P6) * b32 % P6;
  const t1 = pow2(b223, _23n, P6) * b222 % P6;
  const t22 = pow2(t1, _6n, P6) * b22 % P6;
  const root = pow2(t22, _2n5, P6);
  if (!Fp.eql(Fp.sqr(root), y10))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k3) => {
      const n24 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k3, n24);
      const c22 = divNearest(-b1 * k3, n24);
      let k1 = mod(k3 - c1 * a1 - c22 * a22, n24);
      let k22 = mod(-c1 * b1 - c22 * b22, n24);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n24 - k1;
      if (k2neg)
        k22 = n24 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k3);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var fe = (x8) => typeof x8 === "bigint" && _0n6 < x8 && x8 < secp256k1P;
var ge = (x8) => typeof x8 === "bigint" && _0n6 < x8 && x8 < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c14) => c14.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n24) => numberToBytesBE(n24, 32);
var modP = (x8) => mod(x8, secp256k1P);
var modN = (x8) => mod(x8, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q4, a13, b9) => Point.BASE.multiplyAndAddUnsafe(Q4, a13, b9);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p12 = Point.fromPrivateKey(d_);
  const scalar = p12.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p12) };
}
function lift_x(x8) {
  if (!fe(x8))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x8 * x8);
  const c14 = modP(xx * x8 + BigInt(7));
  let y10 = sqrtMod(c14);
  if (y10 % _2n5 !== _0n6)
    y10 = modP(-y10);
  const p12 = new Point(x8, y10, _1n6);
  p12.assertValidity();
  return p12;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m12 = ensureBytes("message", message);
  const { bytes: px, scalar: d9 } = schnorrGetExtPubKey(privateKey);
  const a13 = ensureBytes("auxRand", auxRand, 32);
  const t13 = numTo32b(d9 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a13)));
  const rand = taggedHash("BIP0340/nonce", t13, px, m12);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k3 } = schnorrGetExtPubKey(k_);
  const e3 = challenge(rx, px, m12);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k3 + e3 * d9)), 32);
  if (!schnorrVerify(sig, m12, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m12 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P6 = lift_x(bytesToNumberBE(pub));
    const r23 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r23))
      return false;
    const s12 = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s12))
      return false;
    const e3 = challenge(numTo32b(r23), pointToBytes(P6), m12);
    const R4 = GmulAdd(P6, s12, modN(-e3));
    if (!R4 || !R4.hasEvenY() || R4.toAffine().x !== r23)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i48) => i48.map((j4) => BigInt(j4)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x8, y: y10 } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x8, y10);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_5, i48) => i48);
var Pi = Id.map((i48) => (9 * i48 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i48 = 0; i48 < 4; i48++)
  for (let j4 of [idxL, idxR])
    j4.push(j4[i48].map((k3) => Rho[k3]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i48) => new Uint8Array(i48));
var shiftsL = idxL.map((idx, i48) => idx.map((j4) => shifts[i48][j4]));
var shiftsR = idxR.map((idx, i48) => idx.map((j4) => shifts[i48][j4]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f9(group, x8, y10, z4) {
  if (group === 0)
    return x8 ^ y10 ^ z4;
  else if (group === 1)
    return x8 & y10 | ~x8 & z4;
  else if (group === 2)
    return (x8 | ~y10) ^ z4;
  else if (group === 3)
    return x8 & z4 | y10 & ~z4;
  else
    return x8 ^ (y10 | ~z4);
}
var BUF = new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i48 = 0; i48 < 16; i48++, offset += 4)
      BUF[i48] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i48 = 0; i48 < 16; i48++) {
        const tl = rotl(al + f9(group, bl, cl, dl) + BUF[rl[i48]] + hbl, sl[i48]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i48 = 0; i48 < 16; i48++) {
        const tr = rotl(ar + f9(rGroup, br, cr, dr) + BUF[rr[i48]] + hbr, sr[i48]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/.pnpm/@scure+bip32@1.3.3/node_modules/@scure/bip32/lib/esm/index.js
var Point2 = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber(bytes2) {
  return BigInt(`0x${bytesToHex(bytes2)}`);
}
function numberToBytes(num) {
  return hexToBytes(num.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n24) => {
  if (!Number.isSafeInteger(n24) || n24 < 0 || n24 > 2 ** 32 - 1) {
    throw new Error(`Invalid number=${n24}. Should be from 0 to 2 ** 32 - 1`);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n24, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    bytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    }
    const I5 = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I5.slice(32),
      privateKey: I5.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c14 of parts) {
      const m12 = /^(\d+)('?)$/.exec(c14);
      const m1 = m12 && m12[1];
      if (!m12 || m12.length !== 3 || typeof m1 !== "string") {
        throw new Error(`Invalid child index: ${c14}`);
      }
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m12[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I5 = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I5.slice(0, 32));
    const chainCode = I5.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
        if (added.equals(Point2.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash2) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    bytes(hash2, 32);
    return secp256k1.sign(hash2, this.privKey).toCompactRawBytes();
  }
  verify(hash2, signature) {
    bytes(hash2, 32);
    bytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash2, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    bytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-I7WRJY7K.mjs
var i32 = class i33 extends a5 {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== i33.LENGTH)
      throw new Error(`PublicKey length should be ${i33.LENGTH}`);
    this.key = t13;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  verifySignature(e3) {
    let { message: t13, signature: a13 } = e3, y10 = i.fromHexInput(t13).toUint8Array(), v9 = sha3_256(y10), x8 = a13.toUint8Array();
    return secp256k1.verify(x8, v9, this.toUint8Array());
  }
  serialize(e3) {
    e3.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new i33(t13);
  }
  static load(e3) {
    let t13 = e3.deserializeBytes();
    return new i33(t13);
  }
  static isPublicKey(e3) {
    return e3 instanceof i33;
  }
};
i32.LENGTH = 65;
var u3 = i32;
var r9 = class r10 extends i27 {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== r10.LENGTH)
      throw new Error(`PrivateKey length should be ${r10.LENGTH}`);
    this.key = t13;
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  sign(e3) {
    let t13 = i.fromHexInput(e3), a13 = sha3_256(t13.toUint8Array()), y10 = secp256k1.sign(a13, this.key.toUint8Array());
    return new c5(y10.toCompactRawBytes());
  }
  serialize(e3) {
    e3.serializeBytes(this.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new r10(t13);
  }
  static generate() {
    let e3 = secp256k1.utils.randomPrivateKey();
    return new r10(e3);
  }
  publicKey() {
    let e3 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new u3(e3);
  }
  static fromDerivationPath(e3, t13) {
    if (!D3(e3))
      throw new Error(`Invalid derivation path ${e3}`);
    return r10.fromDerivationPathInner(e3, h6(t13));
  }
  static fromDerivationPathInner(e3, t13) {
    let { privateKey: a13 } = HDKey.fromMasterSeed(t13).derive(e3);
    if (a13 === null)
      throw new Error("Invalid key");
    return new r10(a13);
  }
  static isPrivateKey(e3) {
    return e3 instanceof r10;
  }
};
r9.LENGTH = 32;
var S5 = r9;
var n13 = class n14 extends e {
  constructor(e3) {
    super();
    let t13 = i.fromHexInput(e3);
    if (t13.toUint8Array().length !== n14.LENGTH)
      throw new Error(`Signature length should be ${n14.LENGTH}, recieved ${t13.toUint8Array().length}`);
    this.data = t13;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  toString() {
    return this.data.toString();
  }
  serialize(e3) {
    e3.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes();
    return new n14(t13);
  }
  static load(e3) {
    let t13 = e3.deserializeBytes();
    return new n14(t13);
  }
  static isSignature(e3) {
    return e3 instanceof n14;
  }
};
n13.LENGTH = 64;
var c5 = n13;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FBFMQZTM.mjs
var c6 = class n15 extends a5 {
  constructor(e3) {
    super();
    this.publicKey = e3;
  }
  toUint8Array() {
    return this.publicKey.toUint8Array();
  }
  toString() {
    return this.publicKey.toString();
  }
  verifySignature(e3) {
    let { message: i48, signature: u10 } = e3;
    return this.publicKey.verifySignature({ message: i48, signature: u10 });
  }
  serialize(e3) {
    if (this.publicKey instanceof l5)
      e3.serializeU32AsUleb128(0), this.publicKey.serialize(e3);
    else if (this.publicKey instanceof u3)
      e3.serializeU32AsUleb128(1), this.publicKey.serialize(e3);
    else
      throw new Error("Unknown public key type");
  }
  static deserialize(e3) {
    let i48 = e3.deserializeUleb128AsU32();
    switch (i48) {
      case 0:
        return new n15(l5.load(e3));
      case 1:
        return new n15(u3.load(e3));
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${i48}`);
    }
  }
  static isPublicKey(e3) {
    return e3 instanceof n15;
  }
  isEd25519() {
    return this.publicKey instanceof l5;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof u3;
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UCHGKGCF.mjs
var p8 = class h7 extends a5 {
  constructor(e3) {
    super();
    let { publicKeys: t13, signaturesRequired: r23 } = e3;
    if (r23 < 1)
      throw new Error("The number of required signatures needs to be greater then 0");
    if (t13.length < r23)
      throw new Error(`Provided ${t13.length} public keys is smaller than the ${r23} required signatures`);
    let i48 = [];
    t13.forEach((s12) => {
      s12 instanceof c6 ? i48.push(s12) : i48.push(new c6(s12));
    }), this.publicKeys = i48, this.signaturesRequired = r23;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  createBitmap(e3) {
    let { bits: t13 } = e3, r23 = 128, i48 = new Uint8Array([0, 0, 0, 0]), s12 = /* @__PURE__ */ new Set();
    return t13.forEach((n24, u10) => {
      if (u10 + 1 > this.publicKeys.length)
        throw new Error(`Signature index ${u10 + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (s12.has(n24))
        throw new Error(`Duplicate bit ${n24} detected.`);
      s12.add(n24);
      let a13 = Math.floor(n24 / 8), c14 = i48[a13];
      c14 |= r23 >> n24 % 8, i48[a13] = c14;
    }), i48;
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(e3) {
    throw new Error("not implemented");
  }
  serialize(e3) {
    e3.serializeVector(this.publicKeys), e3.serializeU8(this.signaturesRequired);
  }
  static deserialize(e3) {
    let t13 = e3.deserializeVector(c6), r23 = e3.deserializeU8();
    return new h7({ publicKeys: t13, signaturesRequired: r23 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SBMJNU2O.mjs
var i34 = class i35 extends B {
  constructor(r23) {
    super();
    let { data: t13 } = r23, e3 = i.fromHexInput(t13);
    if (e3.toUint8Array().length !== i35.LENGTH)
      throw new Error(`Authentication Key length should be ${i35.LENGTH}`);
    this.data = e3;
  }
  serialize(r23) {
    r23.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(r23) {
    let t13 = r23.deserializeFixedBytes(i35.LENGTH);
    return new i35({ data: t13 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromPublicKeyAndScheme(r23) {
    let { publicKey: t13, scheme: e3 } = r23, n24;
    switch (e3) {
      case 3:
      case 2: {
        let a13 = t13.bcsToBytes();
        n24 = new Uint8Array([...a13, e3]);
        break;
      }
      case 0:
      case 1: {
        let a13 = t13.toUint8Array(), p12 = i.fromHexInput(a13).toUint8Array();
        n24 = new Uint8Array([...p12, e3]);
        break;
      }
      default:
        throw new Error(`Scheme ${e3} is not supported`);
    }
    let o13 = sha3_256.create();
    o13.update(n24);
    let f13 = o13.digest();
    return new i35({ data: f13 });
  }
  static fromPublicKey(r23) {
    let { publicKey: t13 } = r23, e3;
    if (t13 instanceof l5)
      e3 = 0 .valueOf();
    else if (t13 instanceof g6)
      e3 = 1 .valueOf();
    else if (t13 instanceof c6)
      e3 = 2 .valueOf();
    else if (t13 instanceof p8)
      e3 = 3 .valueOf();
    else
      throw new Error("No supported authentication scheme for public key");
    return i35.fromPublicKeyAndScheme({ publicKey: t13, scheme: e3 });
  }
  derivedAddress() {
    return new c(this.data.toUint8Array());
  }
};
i34.LENGTH = 32;
var h8 = i34;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FP5DPRYL.mjs
var g7 = class a6 {
  constructor(t13) {
    let { privateKey: e3, address: i48, legacy: r23 } = t13, c14 = r23 ?? true;
    if (this.publicKey = e3.publicKey(), this.publicKey instanceof l5)
      c14 ? this.signingScheme = 0 : (this.publicKey = new c6(this.publicKey), this.signingScheme = 2);
    else if (this.publicKey instanceof g6)
      this.signingScheme = 1;
    else if (this.publicKey instanceof u3)
      this.publicKey = new c6(this.publicKey), this.signingScheme = 2;
    else
      throw new Error("Can not create new Account, unsupported public key type");
    this.privateKey = e3, this.accountAddress = i48;
  }
  static generate(t13) {
    let e3 = (t13 == null ? void 0 : t13.legacy) ?? true, i48, r23;
    switch (t13 == null ? void 0 : t13.scheme) {
      case 2:
        i48 = S5.generate(), r23 = new c6(i48.publicKey());
        break;
      default:
        i48 = v4.generate(), e3 === false ? r23 = new c6(i48.publicKey()) : r23 = i48.publicKey();
    }
    let s12 = h8.fromPublicKey({ publicKey: r23 }).derivedAddress();
    return new a6({ privateKey: i48, address: s12, legacy: t13 == null ? void 0 : t13.legacy });
  }
  static fromPrivateKey(t13) {
    let { privateKey: e3, legacy: i48 } = t13, r23 = i48 ?? true, c14;
    if (e3 instanceof S5)
      c14 = new c6(e3.publicKey());
    else if (e3 instanceof v4)
      r23 ? c14 = e3.publicKey() : c14 = new c6(e3.publicKey());
    else
      throw new Error(`Unsupported private key ${e3}`);
    let m12 = h8.fromPublicKey({ publicKey: c14 }).derivedAddress();
    return new a6({ privateKey: e3, address: m12, legacy: r23 });
  }
  static fromPrivateKeyAndAddress(t13) {
    let { privateKey: e3, address: i48, legacy: r23 } = t13;
    return new a6({ privateKey: e3, address: i48, legacy: r23 });
  }
  static fromDerivationPath(t13) {
    let { path: e3, mnemonic: i48, scheme: r23, legacy: c14 } = t13, s12;
    switch (r23) {
      case 2:
        s12 = S5.fromDerivationPath(e3, i48);
        break;
      case 0:
        s12 = v4.fromDerivationPath(e3, i48);
        break;
      default:
        throw new Error(`Unsupported scheme ${r23}`);
    }
    return a6.fromPrivateKey({ privateKey: s12, legacy: c14 });
  }
  static authKey(t13) {
    let { publicKey: e3 } = t13;
    return h8.fromPublicKey({ publicKey: e3 });
  }
  sign(t13) {
    return this.privateKey.sign(t13);
  }
  verifySignature(t13) {
    let { message: e3, signature: i48 } = t13, r23 = i.fromHexInput(e3).toUint8Array();
    return this.publicKey.verifySignature({ message: r23, signature: i48 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YGMT4GQ5.mjs
async function M2(e3) {
  let { aptosConfig: n24, accountAddress: t13 } = e3, { data: o13 } = await g3({ aptosConfig: n24, originMethod: "getInfo", path: `accounts/${c.from(t13).toString()}` });
  return o13;
}
async function io(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3;
  return f2({ aptosConfig: n24, originMethod: "getModules", path: `accounts/${c.from(t13).toString()}/modules`, params: { ledger_version: o13 == null ? void 0 : o13.ledgerVersion, start: o13 == null ? void 0 : o13.offset, limit: (o13 == null ? void 0 : o13.limit) ?? 1e3 } });
}
async function uo(e3) {
  var _a;
  return ((_a = e3.options) == null ? void 0 : _a.ledgerVersion) !== void 0 ? P2(e3) : m4(async () => P2(e3), `module-${e3.accountAddress}-${e3.moduleName}`, 1e3 * 60 * 5)();
}
async function P2(e3) {
  let { aptosConfig: n24, accountAddress: t13, moduleName: o13, options: r23 } = e3, { data: s12 } = await g3({ aptosConfig: n24, originMethod: "getModule", path: `accounts/${c.from(t13).toString()}/module/${o13}`, params: { ledger_version: r23 == null ? void 0 : r23.ledgerVersion } });
  return s12;
}
async function go(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3;
  return f2({ aptosConfig: n24, originMethod: "getTransactions", path: `accounts/${c.from(t13).toString()}/transactions`, params: { start: o13 == null ? void 0 : o13.offset, limit: o13 == null ? void 0 : o13.limit } });
}
async function Ao(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3;
  return f2({ aptosConfig: n24, originMethod: "getResources", path: `accounts/${c.from(t13).toString()}/resources`, params: { ledger_version: o13 == null ? void 0 : o13.ledgerVersion, start: o13 == null ? void 0 : o13.offset, limit: (o13 == null ? void 0 : o13.limit) ?? 999 } });
}
async function K(e3) {
  let { aptosConfig: n24, accountAddress: t13, resourceType: o13, options: r23 } = e3, { data: s12 } = await g3({ aptosConfig: n24, originMethod: "getResource", path: `accounts/${c.from(t13).toString()}/resource/${o13}`, params: { ledger_version: r23 == null ? void 0 : r23.ledgerVersion } });
  return s12.data;
}
async function Q2(e3) {
  let { aptosConfig: n24, authenticationKey: t13, options: o13 } = e3, r23 = await K({ aptosConfig: n24, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: o13 }), { address_map: { handle: s12 } } = r23, a13 = c.from(t13);
  try {
    let i48 = await C2({ aptosConfig: n24, handle: s12, data: { key: a13.toString(), key_type: "address", value_type: "address" }, options: o13 });
    return c.from(i48);
  } catch (i48) {
    if (i48 instanceof s3 && i48.data.error_code === "table_item_not_found")
      return a13;
    throw i48;
  }
}
async function po(e3) {
  let { aptosConfig: n24, accountAddress: t13 } = e3, r23 = { owner_address: { _eq: c.from(t13).toStringLong() }, amount: { _gt: 0 } }, a13 = await p3({ aptosConfig: n24, query: { query: m, variables: { where_condition: r23 } }, originMethod: "getAccountTokensCount" });
  return a13.current_token_ownerships_v2_aggregate.aggregate ? a13.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function fo(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3, s12 = { owner_address: { _eq: c.from(t13).toStringLong() }, amount: { _gt: 0 } };
  (o13 == null ? void 0 : o13.tokenStandard) && (s12.token_standard = { _eq: o13 == null ? void 0 : o13.tokenStandard });
  let a13 = { query: l2, variables: { where_condition: s12, offset: o13 == null ? void 0 : o13.offset, limit: o13 == null ? void 0 : o13.limit, order_by: o13 == null ? void 0 : o13.orderBy } };
  return (await p3({ aptosConfig: n24, query: a13, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function lo(e3) {
  let { aptosConfig: n24, accountAddress: t13, collectionAddress: o13, options: r23 } = e3, s12 = c.from(t13).toStringLong(), a13 = c.from(o13).toStringLong(), i48 = { owner_address: { _eq: s12 }, current_token_data: { collection_id: { _eq: a13 } }, amount: { _gt: 0 } };
  (r23 == null ? void 0 : r23.tokenStandard) && (i48.token_standard = { _eq: r23 == null ? void 0 : r23.tokenStandard });
  let u10 = { query: p, variables: { where_condition: i48, offset: r23 == null ? void 0 : r23.offset, limit: r23 == null ? void 0 : r23.limit, order_by: r23 == null ? void 0 : r23.orderBy } };
  return (await p3({ aptosConfig: n24, query: u10, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function yo(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3, s12 = { owner_address: { _eq: c.from(t13).toStringLong() }, amount: { _gt: 0 } };
  (o13 == null ? void 0 : o13.tokenStandard) && (s12.current_collection = { token_standard: { _eq: o13 == null ? void 0 : o13.tokenStandard } });
  let a13 = { query: c2, variables: { where_condition: s12, offset: o13 == null ? void 0 : o13.offset, limit: o13 == null ? void 0 : o13.limit, order_by: o13 == null ? void 0 : o13.orderBy } };
  return (await p3({ aptosConfig: n24, query: a13, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function mo(e3) {
  let { aptosConfig: n24, accountAddress: t13 } = e3, o13 = c.from(t13).toStringLong(), s12 = await p3({ aptosConfig: n24, query: { query: g2, variables: { address: o13 } }, originMethod: "getAccountTransactionsCount" });
  return s12.account_transactions_aggregate.aggregate ? s12.account_transactions_aggregate.aggregate.count : 0;
}
async function _o(e3) {
  let { aptosConfig: n24, accountAddress: t13, coinType: o13 } = e3, r23 = c.from(t13).toStringLong(), s12 = await I2({ aptosConfig: n24, accountAddress: r23, options: { where: { asset_type: { _eq: o13 } } } });
  return s12[0] ? s12[0].amount : 0;
}
async function I2(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3, r23 = c.from(t13).toStringLong(), s12 = { ...o13 == null ? void 0 : o13.where, owner_address: { _eq: r23 } }, a13 = { query: u, variables: { where_condition: s12, offset: o13 == null ? void 0 : o13.offset, limit: o13 == null ? void 0 : o13.limit, order_by: o13 == null ? void 0 : o13.orderBy } };
  return (await p3({ aptosConfig: n24, query: a13, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function Co(e3) {
  let { aptosConfig: n24, accountAddress: t13 } = e3, o13 = c.from(t13).toStringLong(), s12 = await p3({ aptosConfig: n24, query: { query: _2, variables: { address: o13 } }, originMethod: "getAccountCoinsCount" });
  if (!s12.current_fungible_asset_balances_aggregate.aggregate)
    throw Error("Failed to get the count of account coins");
  return s12.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function ho(e3) {
  let { aptosConfig: n24, accountAddress: t13, options: o13 } = e3, s12 = { owner_address: { _eq: c.from(t13).toStringLong() } }, a13 = { query: d, variables: { where_condition: s12, offset: o13 == null ? void 0 : o13.offset, limit: o13 == null ? void 0 : o13.limit, order_by: o13 == null ? void 0 : o13.orderBy } };
  return (await p3({ aptosConfig: n24, query: a13, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function wo(e3) {
  let { aptosConfig: n24, privateKey: t13 } = e3, o13 = new c6(t13.publicKey());
  if (t13 instanceof S5) {
    let s12 = h8.fromPublicKeyAndScheme({ publicKey: o13, scheme: 2 }).derivedAddress();
    return g7.fromPrivateKeyAndAddress({ privateKey: t13, address: s12 });
  }
  if (t13 instanceof v4) {
    let r23 = h8.fromPublicKeyAndScheme({ publicKey: o13, scheme: 2 });
    if (await G5({ authKey: r23, aptosConfig: n24 })) {
      let u10 = r23.derivedAddress();
      return g7.fromPrivateKeyAndAddress({ privateKey: t13, address: u10, legacy: false });
    }
    let a13 = h8.fromPublicKeyAndScheme({ publicKey: o13, scheme: 0 });
    if (await G5({ authKey: a13, aptosConfig: n24 })) {
      let u10 = a13.derivedAddress();
      return g7.fromPrivateKeyAndAddress({ privateKey: t13, address: u10, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${t13}`);
}
async function G5(e3) {
  let { aptosConfig: n24, authKey: t13 } = e3, o13 = await Q2({ aptosConfig: n24, authenticationKey: t13.derivedAddress() });
  try {
    return await M2({ aptosConfig: n24, accountAddress: o13 }), true;
  } catch (r23) {
    if (r23.status === 404)
      return false;
    throw new Error(`Error while looking for an account info ${o13.toString()}`);
  }
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MKERJNYN.mjs
var R2 = new TextEncoder();
function Z2(e3) {
  return (e3 == null ? void 0 : e3.map((n24) => D2(n24) ? Z(n24) : n24)) ?? [];
}
async function P3(e3, n24, t13, i48) {
  var _a;
  let f13 = (_a = (await uo({ aptosConfig: i48, accountAddress: e3, moduleName: n24 })).abi) == null ? void 0 : _a.exposed_functions.find((o13) => o13.name === t13);
  if (!f13)
    throw new Error(`Could not find entry function ABI for '${e3}::${n24}::${t13}'`);
  if (!f13.is_entry)
    throw new Error(`'${e3}::${n24}::${t13}' is not an entry function`);
  let N7 = W(f13), g9 = [];
  for (let o13 = N7; o13 < f13.params.length; o13 += 1)
    g9.push(Z(f13.params[o13], { allowGenerics: true }));
  return { typeParameters: f13.generic_type_params, parameters: g9 };
}
function a7(e3, n24, t13, i48, u10) {
  if (i48 >= n24.parameters.length)
    throw new Error(`Too many arguments for '${e3}', expected ${n24.parameters.length}`);
  let f13 = n24.parameters[i48];
  return U6(t13, f13, i48, u10);
}
function U6(e3, n24, t13, i48) {
  return G4(e3) ? (m8(n24, e3, t13), e3) : X(e3, n24, t13, i48);
}
function X(e3, n24, t13, i48) {
  if (n24.isBool()) {
    if (M(e3))
      return new U3(e3);
    R("boolean", t13);
  }
  if (n24.isAddress()) {
    if (D2(e3))
      return c.fromString(e3);
    R("string | AccountAddress", t13);
  }
  if (n24.isU8()) {
    if (N4(e3))
      return new p6(e3);
    R("number", t13);
  }
  if (n24.isU16()) {
    if (N4(e3))
      return new b3(e3);
    R("number", t13);
  }
  if (n24.isU32()) {
    if (N4(e3))
      return new y3(e3);
    R("number", t13);
  }
  if (n24.isU64()) {
    if (P(e3))
      return new m6(BigInt(e3));
    R("bigint | number | string", t13);
  }
  if (n24.isU128()) {
    if (P(e3))
      return new B2(BigInt(e3));
    R("bigint | number | string", t13);
  }
  if (n24.isU256()) {
    if (P(e3))
      return new v3(BigInt(e3));
    R("bigint | number | string", t13);
  }
  if (n24.isGeneric()) {
    let u10 = n24.value;
    if (u10 < 0 || u10 >= i48.length)
      throw new Error(`Generic argument ${n24.toString()} is invalid for argument ${t13}`);
    return U6(e3, i48[u10], t13, i48);
  }
  if (n24.isVector()) {
    if (n24.value.isU8()) {
      if (D2(e3))
        return t6.U8(R2.encode(e3));
      if (e3 instanceof Uint8Array)
        return t6.U8(e3);
      if (e3 instanceof ArrayBuffer)
        return t6.U8(new Uint8Array(e3));
    }
    if (Array.isArray(e3))
      return new t6(e3.map((u10) => U6(u10, n24.value, t13, i48)));
    throw new Error(`Type mismatch for argument ${t13}, type '${n24.toString()}'`);
  }
  if (n24.isStruct()) {
    if (n24.isString()) {
      if (D2(e3))
        return new a3(e3);
      R("string", t13);
    }
    if (n24.isObject()) {
      if (D2(e3))
        return c.fromString(e3);
      R("string | AccountAddress", t13);
    }
    if (n24.isOption())
      return w4(e3) ? new f7(null) : new f7(U6(e3, n24.value.typeArgs[0], t13, i48));
    throw new Error(`Unsupported struct input type for argument ${t13}, type '${n24.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${t13}, type '${n24.toString()}'`);
}
function m8(e3, n24, t13) {
  if (e3.isBool()) {
    if (A7(n24))
      return;
    R("Bool", t13);
  }
  if (e3.isAddress()) {
    if (T7(n24))
      return;
    R("AccountAddress", t13);
  }
  if (e3.isU8()) {
    if (x3(n24))
      return;
    R("U8", t13);
  }
  if (e3.isU16()) {
    if (S4(n24))
      return;
    R("U16", t13);
  }
  if (e3.isU32()) {
    if (B3(n24))
      return;
    R("U32", t13);
  }
  if (e3.isU64()) {
    if (U4(n24))
      return;
    R("U64", t13);
  }
  if (e3.isU128()) {
    if (I(n24))
      return;
    R("U128", t13);
  }
  if (e3.isU256()) {
    if (b4(n24))
      return;
    R("U256", t13);
  }
  if (e3.isVector()) {
    if (n24 instanceof t6) {
      n24.values.length > 0 && m8(e3.value, n24.values[0], t13);
      return;
    }
    R("MoveVector", t13);
  }
  if (e3 instanceof b2) {
    if (e3.isString()) {
      if (E2(n24))
        return;
      R("MoveString", t13);
    }
    if (e3.isObject()) {
      if (T7(n24))
        return;
      R("AccountAddress", t13);
    }
    if (e3.isOption()) {
      if (n24 instanceof f7) {
        n24.value !== void 0 && m8(e3.value.typeArgs[0], n24.value, t13);
        return;
      }
      R("MoveOption", t13);
    }
  }
  throw new Error(`Type mismatch for argument ${t13}, expected '${e3.toString()}'`);
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2QV6HI3M.mjs
var s5 = class t8 extends e {
  constructor(r23) {
    super();
    this.signature = r23;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  toString() {
    return this.signature.toString();
  }
  serialize(r23) {
    if (this.signature instanceof d5)
      r23.serializeU32AsUleb128(0), this.signature.serialize(r23);
    else if (this.signature instanceof c5)
      r23.serializeU32AsUleb128(1), this.signature.serialize(r23);
    else
      throw new Error("Unknown signature type");
  }
  static deserialize(r23) {
    let n24 = r23.deserializeUleb128AsU32();
    switch (n24) {
      case 0:
        return new t8(d5.load(r23));
      case 1:
        return new t8(c5.load(r23));
      default:
        throw new Error(`Unknown variant index for AnySignature: ${n24}`);
    }
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ERWQOVBF.mjs
var n16 = class extends B {
  static deserialize(t13) {
    let i48 = t13.deserializeUleb128AsU32();
    switch (i48) {
      case 0:
        return a8.load(t13);
      case 1:
        return u4.load(t13);
      case 2:
        return l6.load(t13);
      case 3:
        return c7.load(t13);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${i48}`);
    }
  }
  isEd25519() {
    return this instanceof a8;
  }
  isMultiEd25519() {
    return this instanceof u4;
  }
  isSingleKey() {
    return this instanceof l6;
  }
  isMultiKey() {
    return this instanceof c7;
  }
};
var a8 = class s6 extends n16 {
  constructor(i48, e3) {
    super();
    this.public_key = i48, this.signature = e3;
  }
  serialize(i48) {
    i48.serializeU32AsUleb128(0), this.public_key.serialize(i48), this.signature.serialize(i48);
  }
  static load(i48) {
    let e3 = l5.deserialize(i48), r23 = d5.deserialize(i48);
    return new s6(e3, r23);
  }
};
var u4 = class s7 extends n16 {
  constructor(i48, e3) {
    super();
    this.public_key = i48, this.signature = e3;
  }
  serialize(i48) {
    i48.serializeU32AsUleb128(1), this.public_key.serialize(i48), this.signature.serialize(i48);
  }
  static load(i48) {
    let e3 = g6.deserialize(i48), r23 = p7.deserialize(i48);
    return new s7(e3, r23);
  }
};
var l6 = class s8 extends n16 {
  constructor(i48, e3) {
    super();
    this.public_key = i48, this.signature = e3;
  }
  serialize(i48) {
    i48.serializeU32AsUleb128(2), this.public_key.serialize(i48), this.signature.serialize(i48);
  }
  static load(i48) {
    let e3 = c6.deserialize(i48), r23 = s5.deserialize(i48);
    return new s8(e3, r23);
  }
};
var c7 = class s9 extends n16 {
  constructor(i48, e3, r23) {
    super();
    this.public_keys = i48, this.signatures = e3, this.signatures_bitmap = r23;
  }
  serialize(i48) {
    i48.serializeU32AsUleb128(3), this.public_keys.serialize(i48), i48.serializeVector(this.signatures), i48.serializeBytes(this.signatures_bitmap);
  }
  static load(i48) {
    let e3 = p8.deserialize(i48), r23 = i48.deserializeVector(s5), z4 = i48.deserializeBytes();
    return new s9(e3, r23, z4);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NWRKJFHV.mjs
var c8 = class extends B {
  static deserialize(t13) {
    let e3 = t13.deserializeUleb128AsU32();
    switch (e3) {
      case 0:
        return d6.load(t13);
      case 1:
        return u5.load(t13);
      case 2:
        return l7.load(t13);
      case 3:
        return A9.load(t13);
      case 4:
        return y5.load(t13);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${e3}`);
    }
  }
};
var d6 = class i36 extends c8 {
  constructor(e3, r23) {
    super();
    this.public_key = e3, this.signature = r23;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(0), this.public_key.serialize(e3), this.signature.serialize(e3);
  }
  static load(e3) {
    let r23 = l5.deserialize(e3), s12 = d5.deserialize(e3);
    return new i36(r23, s12);
  }
};
var u5 = class i37 extends c8 {
  constructor(e3, r23) {
    super();
    this.public_key = e3, this.signature = r23;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(1), this.public_key.serialize(e3), this.signature.serialize(e3);
  }
  static load(e3) {
    let r23 = g6.deserialize(e3), s12 = p7.deserialize(e3);
    return new i37(r23, s12);
  }
};
var l7 = class i38 extends c8 {
  constructor(e3, r23, s12) {
    super();
    this.sender = e3, this.secondary_signer_addresses = r23, this.secondary_signers = s12;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(2), this.sender.serialize(e3), e3.serializeVector(this.secondary_signer_addresses), e3.serializeVector(this.secondary_signers);
  }
  static load(e3) {
    let r23 = n16.deserialize(e3), s12 = e3.deserializeVector(c), a13 = e3.deserializeVector(n16);
    return new i38(r23, s12, a13);
  }
};
var A9 = class i39 extends c8 {
  constructor(e3, r23, s12, a13) {
    super();
    this.sender = e3, this.secondary_signer_addresses = r23, this.secondary_signers = s12, this.fee_payer = a13;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(3), this.sender.serialize(e3), e3.serializeVector(this.secondary_signer_addresses), e3.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e3), this.fee_payer.authenticator.serialize(e3);
  }
  static load(e3) {
    let r23 = n16.deserialize(e3), s12 = e3.deserializeVector(c), a13 = e3.deserializeVector(n16), z4 = c.deserialize(e3), S8 = n16.deserialize(e3), E6 = { address: z4, authenticator: S8 };
    return new i39(r23, s12, a13, E6);
  }
};
var y5 = class i40 extends c8 {
  constructor(e3) {
    super();
    this.sender = e3;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(4), this.sender.serialize(e3);
  }
  static load(e3) {
    let r23 = n16.deserialize(e3);
    return new i40(r23);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7D5LHQNS.mjs
var o7 = class t9 extends B {
  constructor(e3, r23) {
    super();
    this.address = e3, this.name = r23;
  }
  static fromStr(e3) {
    let r23 = e3.split("::");
    if (r23.length !== 2)
      throw new Error("Invalid module id.");
    return new t9(c.fromString(r23[0]), new r5(r23[1]));
  }
  serialize(e3) {
    this.address.serialize(e3), this.name.serialize(e3);
  }
  static deserialize(e3) {
    let r23 = c.deserialize(e3), n24 = r5.deserialize(e3);
    return new t9(r23, n24);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-PPTG6BDV.mjs
var t10 = class l8 extends B {
  constructor(e3) {
    super();
    this.value = new t7(e3);
  }
  serialize(e3) {
    e3.serialize(this.value);
  }
  serializeForEntryFunction(e3) {
    e3.serializeU32AsUleb128(this.value.value.length), e3.serialize(this);
  }
  static deserialize(e3, s12) {
    let a13 = t7.deserialize(e3, s12);
    return new l8(a13.value);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OWZLBIDD.mjs
function D4(r23) {
  let e3 = r23.deserializeUleb128AsU32();
  switch (e3) {
    case 0:
      return p6.deserialize(r23);
    case 1:
      return m6.deserialize(r23);
    case 2:
      return B2.deserialize(r23);
    case 3:
      return c.deserialize(r23);
    case 4:
      return t6.deserialize(r23, p6);
    case 5:
      return U3.deserialize(r23);
    case 6:
      return b3.deserialize(r23);
    case 7:
      return y3.deserialize(r23);
    case 8:
      return v3.deserialize(r23);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e3}`);
  }
}
var a9 = class extends B {
  static deserialize(e3) {
    let t13 = e3.deserializeUleb128AsU32();
    switch (t13) {
      case 0:
        return A10.load(e3);
      case 2:
        return z2.load(e3);
      case 3:
        return h9.load(e3);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${t13}`);
    }
  }
};
var A10 = class r11 extends a9 {
  constructor(t13) {
    super();
    this.script = t13;
  }
  serialize(t13) {
    t13.serializeU32AsUleb128(0), this.script.serialize(t13);
  }
  static load(t13) {
    let i48 = U7.deserialize(t13);
    return new r11(i48);
  }
};
var z2 = class r12 extends a9 {
  constructor(t13) {
    super();
    this.entryFunction = t13;
  }
  serialize(t13) {
    t13.serializeU32AsUleb128(2), this.entryFunction.serialize(t13);
  }
  static load(t13) {
    let i48 = l9.deserialize(t13);
    return new r12(i48);
  }
};
var h9 = class r13 extends a9 {
  constructor(t13) {
    super();
    this.multiSig = t13;
  }
  serialize(t13) {
    t13.serializeU32AsUleb128(3), this.multiSig.serialize(t13);
  }
  static load(t13) {
    let i48 = f10.deserialize(t13);
    return new r13(i48);
  }
};
var l9 = class r14 {
  constructor(e3, t13, i48, n24) {
    this.module_name = e3, this.function_name = t13, this.type_args = i48, this.args = n24;
  }
  static build(e3, t13, i48, n24) {
    return new r14(o7.fromStr(e3), new r5(t13), i48, n24);
  }
  serialize(e3) {
    this.module_name.serialize(e3), this.function_name.serialize(e3), e3.serializeVector(this.type_args), e3.serializeU32AsUleb128(this.args.length), this.args.forEach((t13) => {
      t13.serializeForEntryFunction(e3);
    });
  }
  static deserialize(e3) {
    let t13 = o7.deserialize(e3), i48 = r5.deserialize(e3), n24 = e3.deserializeVector(t5), o13 = e3.deserializeUleb128AsU32(), s12 = new Array();
    for (let c14 = 0; c14 < o13; c14 += 1) {
      let M6 = e3.deserializeUleb128AsU32(), B5 = t10.deserialize(e3, M6);
      s12.push(B5);
    }
    return new r14(t13, i48, n24, s12);
  }
};
var U7 = class r15 {
  constructor(e3, t13, i48) {
    this.bytecode = e3, this.type_args = t13, this.args = i48;
  }
  serialize(e3) {
    e3.serializeBytes(this.bytecode), e3.serializeVector(this.type_args), e3.serializeU32AsUleb128(this.args.length), this.args.forEach((t13) => {
      t13.serializeForScriptFunction(e3);
    });
  }
  static deserialize(e3) {
    let t13 = e3.deserializeBytes(), i48 = e3.deserializeVector(t5), n24 = e3.deserializeUleb128AsU32(), o13 = new Array();
    for (let s12 = 0; s12 < n24; s12 += 1) {
      let c14 = D4(e3);
      o13.push(c14);
    }
    return new r15(t13, i48, o13);
  }
};
var f10 = class r16 {
  constructor(e3, t13) {
    this.multisig_address = e3, this.transaction_payload = t13;
  }
  serialize(e3) {
    this.multisig_address.serialize(e3), this.transaction_payload === void 0 ? e3.serializeBool(false) : (e3.serializeBool(true), this.transaction_payload.serialize(e3));
  }
  static deserialize(e3) {
    let t13 = c.deserialize(e3), i48 = e3.deserializeBool(), n24;
    return i48 && (n24 = b5.deserialize(e3)), new r16(t13, n24);
  }
};
var b5 = class r17 extends B {
  constructor(t13) {
    super();
    this.transaction_payload = t13;
  }
  serialize(t13) {
    t13.serializeU32AsUleb128(0), this.transaction_payload.serialize(t13);
  }
  static deserialize(t13) {
    return t13.deserializeUleb128AsU32(), new r17(l9.deserialize(t13));
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QKTV6AZ7.mjs
var r18 = class a10 extends B {
  constructor(e3) {
    super();
    this.chainId = e3;
  }
  serialize(e3) {
    e3.serializeU8(this.chainId);
  }
  static deserialize(e3) {
    let s12 = e3.deserializeU8();
    return new a10(s12);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WC2WSKYZ.mjs
var o8 = class i41 extends B {
  constructor(e3, s12, a13, n24, d9, l12, _5) {
    super();
    this.sender = e3, this.sequence_number = s12, this.payload = a13, this.max_gas_amount = n24, this.gas_unit_price = d9, this.expiration_timestamp_secs = l12, this.chain_id = _5;
  }
  serialize(e3) {
    this.sender.serialize(e3), e3.serializeU64(this.sequence_number), this.payload.serialize(e3), e3.serializeU64(this.max_gas_amount), e3.serializeU64(this.gas_unit_price), e3.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e3);
  }
  static deserialize(e3) {
    let s12 = c.deserialize(e3), a13 = e3.deserializeU64(), n24 = a9.deserialize(e3), d9 = e3.deserializeU64(), l12 = e3.deserializeU64(), _5 = e3.deserializeU64(), b9 = r18.deserialize(e3);
    return new i41(s12, a13, n24, d9, l12, _5, b9);
  }
};
var c9 = class extends B {
  static deserialize(r23) {
    let e3 = r23.deserializeUleb128AsU32();
    switch (e3) {
      case 0:
        return p9.load(r23);
      case 1:
        return y6.load(r23);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${e3}`);
    }
  }
};
var p9 = class i42 extends c9 {
  constructor(e3, s12) {
    super();
    this.raw_txn = e3, this.secondary_signer_addresses = s12;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(0), this.raw_txn.serialize(e3), e3.serializeVector(this.secondary_signer_addresses);
  }
  static load(e3) {
    let s12 = o8.deserialize(e3), a13 = e3.deserializeVector(c);
    return new i42(s12, a13);
  }
};
var y6 = class i43 extends c9 {
  constructor(e3, s12, a13) {
    super();
    this.raw_txn = e3, this.secondary_signer_addresses = s12, this.fee_payer_address = a13;
  }
  serialize(e3) {
    e3.serializeU32AsUleb128(1), this.raw_txn.serialize(e3), e3.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e3);
  }
  static load(e3) {
    let s12 = o8.deserialize(e3), a13 = e3.deserializeVector(c), n24 = c.deserialize(e3);
    return new i43(s12, a13, n24);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XQIWF5HY.mjs
var n17 = class o9 extends B {
  constructor(t13, a13) {
    super();
    this.raw_txn = t13, this.authenticator = a13;
  }
  serialize(t13) {
    this.raw_txn.serialize(t13), this.authenticator.serialize(t13);
  }
  static deserialize(t13) {
    let a13 = o8.deserialize(t13), s12 = c8.deserialize(t13);
    return new o9(a13, s12);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-77SKA4HT.mjs
var n18 = { mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql", testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql", devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql", randomnet: "https://indexer-randomnet.hasura.app/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
var o10 = { mainnet: "https://fullnode.mainnet.aptoslabs.com/v1", testnet: "https://fullnode.testnet.aptoslabs.com/v1", devnet: "https://fullnode.devnet.aptoslabs.com/v1", randomnet: "https://fullnode.random.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
var a11 = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", randomnet: "https://faucet.random.aptoslabs.com", local: "http://127.0.0.1:8081" };
var e2 = ((t13) => (t13.MAINNET = "mainnet", t13.TESTNET = "testnet", t13.DEVNET = "devnet", t13.RANDOMNET = "randomnet", t13.LOCAL = "local", t13.CUSTOM = "custom", t13))(e2 || {});
var s10 = { mainnet: 1, testnet: 2, randomnet: 70 };
var r19 = { mainnet: "mainnet", testnet: "testnet", devnet: "devnet", randomnet: "randomnet", local: "local", custom: "custom" };

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SZYATFM7.mjs
async function Wn(n24) {
  if ($3(n24))
    return cn(n24);
  let { moduleAddress: e3, moduleName: t13, functionName: o13 } = L2(n24.function), a13 = await m4(async () => P3(e3, t13, o13, n24.aptosConfig), `entry-function-${n24.aptosConfig.network}-${e3}-${t13}-${o13}`, 1e3 * 60 * 5)();
  return sn({ abi: a13, ...n24 });
}
function sn(n24) {
  let e3 = n24.abi, { moduleAddress: t13, moduleName: o13, functionName: a13 } = L2(n24.function), r23 = Z2(n24.typeArguments);
  if (r23.length !== e3.typeParameters.length)
    throw new Error(`Type argument count mismatch, expected ${e3.typeParameters.length}, received ${r23.length}`);
  let i48 = n24.functionArguments.map((s12, A13) => a7(n24.function, e3, s12, A13, r23));
  if (i48.length !== e3.parameters.length)
    throw new Error(`Too few arguments for '${t13}::${o13}::${a13}', expected ${e3.parameters.length} but got ${i48.length}`);
  let c14 = l9.build(`${t13}::${o13}`, a13, r23, i48);
  if ("multisigAddress" in n24) {
    let s12 = c.from(n24.multisigAddress);
    return new h9(new f10(s12, new b5(c14)));
  }
  return new z2(c14);
}
function cn(n24) {
  return new A10(new U7(i.fromHexInput(n24.bytecode).toUint8Array(), n24.typeArguments ?? [], n24.functionArguments));
}
async function un(n24) {
  let { aptosConfig: e3, sender: t13, payload: o13, options: a13, feePayerAddress: r23 } = n24, i48 = s10[e3.network] ? Promise.resolve({ chain_id: s10[e3.network] }) : l4({ aptosConfig: e3 }), c14 = (a13 == null ? void 0 : a13.gasUnitPrice) ? Promise.resolve({ gas_estimate: a13.gasUnitPrice }) : L({ aptosConfig: e3 }), [{ chain_id: s12 }, { gas_estimate: A13 }] = await Promise.all([i48, c14]), y10 = (a13 == null ? void 0 : a13.accountSequenceNumber) !== void 0 ? Promise.resolve({ sequence_number: a13.accountSequenceNumber }) : M2({ aptosConfig: e3, accountAddress: t13 }), m12;
  if (r23 && c.from(r23).equals(c.ZERO))
    try {
      let { sequence_number: T10 } = await y10;
      m12 = T10;
    } catch {
      m12 = "0";
    }
  else {
    let { sequence_number: T10 } = await y10;
    m12 = T10;
  }
  let { maxGasAmount: en, gasUnitPrice: an, expireTimestamp: rn } = { maxGasAmount: (a13 == null ? void 0 : a13.maxGasAmount) ? BigInt(a13.maxGasAmount) : BigInt(o4), gasUnitPrice: BigInt(A13), expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + N), ...a13 };
  return new o8(c.from(t13), BigInt(m12), o13, BigInt(en), BigInt(an), BigInt(rn), new r18(s12));
}
async function $n(n24) {
  var _a;
  let { aptosConfig: e3, sender: t13, payload: o13, options: a13, feePayerAddress: r23 } = n24, i48 = await un({ aptosConfig: e3, sender: t13, payload: o13, options: a13, feePayerAddress: r23 });
  if ("secondarySignerAddresses" in n24) {
    let c14 = ((_a = n24.secondarySignerAddresses) == null ? void 0 : _a.map((s12) => c.from(s12))) ?? [];
    return { rawTransaction: i48, secondarySignerAddresses: c14, feePayerAddress: n24.feePayerAddress ? c.from(n24.feePayerAddress) : void 0 };
  }
  return { rawTransaction: i48, feePayerAddress: n24.feePayerAddress ? c.from(n24.feePayerAddress) : void 0 };
}
function Cn(n24) {
  let { signerPublicKey: e3, transaction: t13, secondarySignersPublicKeys: o13, feePayerPublicKey: a13 } = n24, r23 = I3(e3);
  if (t13.feePayerAddress) {
    let c14 = new y6(t13.rawTransaction, t13.secondarySignerAddresses ?? [], t13.feePayerAddress), s12 = [];
    o13 && (s12 = o13.map((m12) => I3(m12)));
    let A13 = I3(a13), y10 = new A9(r23, t13.secondarySignerAddresses ?? [], s12, { address: t13.feePayerAddress, authenticator: A13 });
    return new n17(c14.raw_txn, y10).bcsToBytes();
  }
  if (t13.secondarySignerAddresses) {
    let c14 = new p9(t13.rawTransaction, t13.secondarySignerAddresses), s12 = [];
    s12 = o13.map((y10) => I3(y10));
    let A13 = new l7(r23, t13.secondarySignerAddresses, s12);
    return new n17(c14.raw_txn, A13).bcsToBytes();
  }
  let i48;
  if (r23 instanceof a8)
    i48 = new d6(r23.public_key, r23.signature);
  else if (r23 instanceof l6)
    i48 = new y5(r23);
  else
    throw new Error("Invalid public key");
  return new n17(t13.rawTransaction, i48).bcsToBytes();
}
function I3(n24) {
  if (n24 instanceof c6) {
    if (n24.publicKey instanceof l5)
      return new l6(n24, new s5(new d5(new Uint8Array(64))));
    if (n24.publicKey instanceof u3)
      return new l6(n24, new s5(new c5(new Uint8Array(64))));
  }
  return new a8(new l5(n24.toUint8Array()), new d5(new Uint8Array(64)));
}
function Kn(n24) {
  let { signer: e3, transaction: t13 } = n24, o13 = An(t13), a13 = e3.sign(o13);
  switch (e3.signingScheme) {
    case 0:
      return new a8(new l5(e3.publicKey.toUint8Array()), new d5(a13.toUint8Array()));
    case 2:
      if (!c6.isPublicKey(e3.publicKey))
        throw new Error(`Cannot sign transaction, public key does not match ${e3.signingScheme}`);
      return new l6(e3.publicKey, new s5(a13));
    default:
      throw new Error(`Cannot sign transaction, signing scheme ${e3.signingScheme} not supported`);
  }
}
function kn(n24) {
  let { transaction: e3, senderAuthenticator: t13, feePayerAuthenticator: o13, additionalSignersAuthenticators: a13 } = n24, r23 = tn(e3);
  if ((o13 || a13) && (r23 instanceof p9 || r23 instanceof y6))
    return dn(r23, t13, o13, a13);
  if (t13 instanceof a8 && r23 instanceof o8) {
    let i48 = new d6(t13.public_key, t13.signature);
    return new n17(r23, i48).bcsToBytes();
  }
  if ((t13 instanceof l6 || t13 instanceof c7) && r23 instanceof o8) {
    let i48 = new y5(t13);
    return new n17(r23, i48).bcsToBytes();
  }
  throw new Error(`Cannot generate a signed transaction, ${t13} is not a supported account authentication scheme`);
}
function tn(n24) {
  return n24.feePayerAddress ? new y6(n24.rawTransaction, n24.secondarySignerAddresses ?? [], n24.feePayerAddress) : n24.secondarySignerAddresses ? new p9(n24.rawTransaction, n24.secondarySignerAddresses) : n24.rawTransaction;
}
function dn(n24, e3, t13, o13) {
  if (n24 instanceof y6) {
    if (!t13)
      throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    let a13 = new A9(e3, n24.secondary_signer_addresses, o13 ?? [], { address: n24.fee_payer_address, authenticator: t13 });
    return new n17(n24.raw_txn, a13).bcsToBytes();
  }
  if (n24 instanceof p9) {
    if (!o13)
      throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    let a13 = new l7(e3, n24.secondary_signer_addresses, o13 ?? []);
    return new n17(n24.raw_txn, a13).bcsToBytes();
  }
  throw new Error(`Cannot prepare multi signers transaction to submission, ${typeof n24} transaction is not supported`);
}
function An(n24) {
  let e3 = tn(n24), t13 = sha3_256.create();
  if (e3 instanceof o8)
    t13.update(a2);
  else if (e3 instanceof p9)
    t13.update(r3);
  else if (e3 instanceof y6)
    t13.update(r3);
  else
    throw new Error(`Unknown transaction type to sign on: ${e3}`);
  let o13 = t13.digest(), a13 = e3.bcsToBytes(), r23 = new Uint8Array(o13.length + a13.length);
  return r23.set(o13), r23.set(a13, o13.length), r23;
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-O57QZZF2.mjs
var c10 = class extends B {
  constructor(e3) {
    super();
    this.accountAddress = c.ONE;
    this.moduleName = new a3("account");
    this.structName = new a3("RotationProofChallenge");
    this.sequenceNumber = new m6(e3.sequenceNumber), this.originator = e3.originator, this.currentAuthKey = e3.currentAuthKey, this.newPublicKey = t6.U8(e3.newPublicKey.toUint8Array());
  }
  serialize(e3) {
    e3.serialize(this.accountAddress), e3.serialize(this.moduleName), e3.serialize(this.structName), e3.serialize(this.sequenceNumber), e3.serialize(this.originator), e3.serialize(this.currentAuthKey), e3.serialize(this.newPublicKey);
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6UNBJAV6.mjs
async function h10(t13) {
  let a13 = await D5(t13);
  return G6(t13, a13);
}
async function D5(t13) {
  let { aptosConfig: a13, data: n24 } = t13, e3, o13;
  return "bytecode" in n24 ? o13 = await Wn(n24) : "multisigAddress" in n24 ? n24.abi ? o13 = sn({ abi: n24.abi, ...n24 }) : (e3 = { aptosConfig: a13, multisigAddress: n24.multisigAddress, function: n24.function, functionArguments: n24.functionArguments, typeArguments: n24.typeArguments }, o13 = await Wn(e3)) : n24.abi ? o13 = sn({ abi: n24.abi, ...n24 }) : (e3 = { aptosConfig: a13, function: n24.function, functionArguments: n24.functionArguments, typeArguments: n24.typeArguments }, o13 = await Wn(e3)), o13;
}
async function G6(t13, a13) {
  let { aptosConfig: n24, sender: e3, options: o13 } = t13, i48;
  if (U8(t13) && (i48 = c.ZERO.toString()), _3(t13)) {
    let { secondarySignerAddresses: c14 } = t13;
    return $n({ aptosConfig: n24, sender: e3, payload: a13, options: o13, secondarySignerAddresses: c14, feePayerAddress: i48 });
  }
  return $n({ aptosConfig: n24, sender: e3, payload: a13, options: o13, feePayerAddress: i48 });
}
function U8(t13) {
  return t13.withFeePayer === true;
}
function _3(t13) {
  return "secondarySignerAddresses" in t13;
}
function Y(t13) {
  let { transaction: a13 } = t13;
  return An(a13);
}
function K2(t13) {
  return Kn({ ...t13 });
}
async function $4(t13) {
  var _a, _b, _c;
  let { aptosConfig: a13, transaction: n24, signerPublicKey: e3, secondarySignersPublicKeys: o13, feePayerPublicKey: i48, options: c14 } = t13, u10 = Cn({ transaction: n24, signerPublicKey: e3, secondarySignersPublicKeys: o13, feePayerPublicKey: i48, options: c14 }), { data: A13 } = await A3({ aptosConfig: a13, body: u10, path: "transactions/simulate", params: { estimate_gas_unit_price: ((_a = t13.options) == null ? void 0 : _a.estimateGasUnitPrice) ?? false, estimate_max_gas_amount: ((_b = t13.options) == null ? void 0 : _b.estimateMaxGasAmount) ?? false, estimate_prioritized_gas_unit_price: ((_c = t13.options) == null ? void 0 : _c.estimatePrioritizedGasUnitPrice) ?? false }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return A13;
}
async function B4(t13) {
  let { aptosConfig: a13 } = t13, n24 = kn({ ...t13 }), { data: e3 } = await A3({ aptosConfig: a13, body: n24, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return e3;
}
async function M3(t13) {
  let { aptosConfig: a13, signer: n24, transaction: e3 } = t13, o13 = K2({ signer: n24, transaction: e3 });
  return B4({ aptosConfig: a13, transaction: e3, senderAuthenticator: o13 });
}
var v5 = { typeParameters: [], parameters: [y2.u8(), new y2(y2.u8())] };
async function nn(t13) {
  let { aptosConfig: a13, account: n24, metadataBytes: e3, moduleBytecode: o13, options: i48 } = t13, c14 = o13.map((u10) => t6.U8(u10));
  return h10({ aptosConfig: a13, sender: c.from(n24), data: { function: "0x1::code::publish_package_txn", functionArguments: [t6.U8(e3), new t6(c14)], abi: v5 }, options: i48 });
}
var N5 = { typeParameters: [], parameters: [new u2(), y2.u8(), new u2(), y2.u8(), y2.u8(), y2.u8()] };
async function tn2(t13) {
  let { aptosConfig: a13, fromAccount: n24, toNewPrivateKey: e3 } = t13, o13 = await M2({ aptosConfig: a13, accountAddress: n24.accountAddress }), i48 = g7.fromPrivateKey({ privateKey: e3, legacy: true }), u10 = new c10({ sequenceNumber: BigInt(o13.sequence_number), originator: n24.accountAddress, currentAuthKey: c.from(o13.authentication_key), newPublicKey: i48.publicKey }).bcsToBytes(), A13 = n24.sign(u10), R4 = i48.sign(u10), x8 = await h10({ aptosConfig: a13, sender: n24.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new p6(n24.signingScheme.valueOf()), t6.U8(n24.publicKey.toUint8Array()), new p6(i48.signingScheme.valueOf()), t6.U8(i48.publicKey.toUint8Array()), t6.U8(A13.toUint8Array()), t6.U8(R4.toUint8Array())], abi: N5 } });
  return M3({ aptosConfig: a13, signer: n24, transaction: x8 });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JLL7BCD4.mjs
var o11 = class {
  constructor(n24) {
    this.config = n24;
  }
  async simple(n24) {
    return h10({ aptosConfig: this.config, ...n24 });
  }
  async multiAgent(n24) {
    return h10({ aptosConfig: this.config, ...n24 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-D2GNCG27.mjs
var n19 = () => Math.floor(Date.now() / 1e3);
var r20 = class {
  constructor(t13, i48, o13, a13, c14) {
    this.lastUncommintedNumber = null;
    this.currentNumber = null;
    this.lock = false;
    this.aptosConfig = t13, this.account = i48, this.maxWaitTime = o13, this.maximumInFlight = a13, this.sleepTime = c14;
  }
  async nextSequenceNumber() {
    for (; this.lock; )
      await r4(this.sleepTime);
    this.lock = true;
    let t13 = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let i48 = n19();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; )
          await r4(this.sleepTime), n19() - i48 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      t13 = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (i48) {
      console.error("error in getting next sequence number for this account", i48);
    } finally {
      this.lock = false;
    }
    return t13;
  }
  async initialize() {
    let { sequence_number: t13 } = await M2({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(t13), this.lastUncommintedNumber = BigInt(t13);
  }
  async update() {
    let { sequence_number: t13 } = await M2({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(t13), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; )
        await r4(this.sleepTime);
      this.lock = true;
      try {
        await this.update();
        let t13 = n19();
        for (; this.lastUncommintedNumber !== this.currentNumber; )
          n19() - t13 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await r4(this.sleepTime), await this.update());
      } catch (t13) {
        console.error("error in synchronizing this account sequence number with the one on chain", t13);
      } finally {
        this.lock = false;
      }
    }
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-U6Z4FNB7.mjs
var i44 = class {
  constructor() {
    this.queue = [];
    this.pendingDequeue = [];
    this.cancelled = false;
  }
  enqueue(e3) {
    var _a;
    if (this.cancelled = false, this.pendingDequeue.length > 0) {
      (_a = this.pendingDequeue.shift()) == null ? void 0 : _a.resolve(e3);
      return;
    }
    this.queue.push(e3);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e3, u10) => {
      this.pendingDequeue.push({ resolve: e3, reject: u10 });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e3 }) => {
      e3(new n20("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
};
var n20 = class extends Error {
};

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Z6XNTGNK.mjs
var p10 = "fulfilled";
var T8 = ((n24) => (n24.TransactionSent = "transactionSent", n24.TransactionSendFailed = "transactionSendFailed", n24.TransactionExecuted = "transactionExecuted", n24.TransactionExecutionFailed = "transactionExecutionFailed", n24.ExecutionFinish = "executionFinish", n24))(T8 || {});
var m9 = class extends eventemitter3_default {
  constructor(t13, e3, a13 = 30, n24 = 100, i48 = 10) {
    super();
    this.taskQueue = new i44();
    this.transactionsQueue = new i44();
    this.outstandingTransactions = new i44();
    this.sentTransactions = [];
    this.executedTransactions = [];
    this.aptosConfig = t13, this.account = e3, this.started = false, this.accountSequnceNumber = new r20(t13, e3, a13, n24, i48);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let t13 = await this.accountSequnceNumber.nextSequenceNumber();
        if (t13 === null)
          return;
        let e3 = await this.generateNextTransaction(this.account, t13);
        if (!e3)
          return;
        let a13 = M3({ aptosConfig: this.aptosConfig, transaction: e3, signer: this.account });
        await this.outstandingTransactions.enqueue([a13, t13]);
      }
    } catch (t13) {
      if (t13 instanceof n20)
        return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t13}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let t13 = [], e3 = [], [a13, n24] = await this.outstandingTransactions.dequeue();
        for (t13.push(a13), e3.push(n24); !this.outstandingTransactions.isEmpty(); )
          [a13, n24] = await this.outstandingTransactions.dequeue(), t13.push(a13), e3.push(n24);
        let i48 = await Promise.allSettled(t13);
        for (let s12 = 0; s12 < i48.length && s12 < e3.length; s12 += 1) {
          let r23 = i48[s12];
          n24 = e3[s12], r23.status === p10 ? (this.sentTransactions.push([r23.value.hash, n24, null]), this.emit("transactionSent", { message: `transaction hash ${r23.value.hash} has been committed to chain`, transactionHash: r23.value.hash }), await this.checkTransaction(r23, n24)) : (this.sentTransactions.push([r23.status, n24, r23.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${r23.reason}`, error: r23.reason }));
        }
        this.emit("executionFinish", { message: `execute ${i48.length} transactions finished` });
      }
    } catch (t13) {
      if (t13 instanceof n20)
        return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t13}`);
    }
  }
  async checkTransaction(t13, e3) {
    try {
      let a13 = [];
      a13.push(G2({ aptosConfig: this.aptosConfig, transactionHash: t13.value.hash }));
      let n24 = await Promise.allSettled(a13);
      for (let i48 = 0; i48 < n24.length; i48 += 1) {
        let s12 = n24[i48];
        s12.status === p10 ? (this.executedTransactions.push([s12.value.hash, e3, null]), this.emit("transactionExecuted", { message: `transaction hash ${s12.value.hash} has been executed on chain`, transactionHash: t13.value.hash })) : (this.executedTransactions.push([s12.status, e3, s12.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${s12.reason}`, error: s12.reason }));
      }
    } catch (a13) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${a13}`);
    }
  }
  async push(t13, e3) {
    this.transactionsQueue.enqueue([t13, e3]);
  }
  async generateNextTransaction(t13, e3) {
    if (this.transactionsQueue.isEmpty())
      return;
    let [a13, n24] = await this.transactionsQueue.dequeue();
    return h10({ aptosConfig: this.aptosConfig, sender: t13.accountAddress, data: a13, options: { ...n24, accountSequenceNumber: e3 } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); )
        await (await this.taskQueue.dequeue())();
    } catch (t13) {
      throw new Error(`Unable to start transaction batching: ${t13}`);
    }
  }
  start() {
    if (this.started)
      throw new Error("worker has already started");
    this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled())
      throw new Error("worker has already stopped");
    this.started = false, this.taskQueue.cancel();
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-J6RCCKOA.mjs
var i45 = class extends eventemitter3_default {
  constructor(t13) {
    super();
    this.config = t13;
  }
  start(t13) {
    let { sender: n24 } = t13;
    this.account = n24, this.transactionWorker = new m9(this.config, n24), this.transactionWorker.start(), this.registerToEvents();
  }
  push(t13) {
    let { data: n24, options: o13 } = t13;
    for (let r23 of n24)
      this.transactionWorker.push(r23, o13);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (t13) => {
      this.emit("transactionSent", t13);
    }), this.transactionWorker.on("transactionSendFailed", async (t13) => {
      this.emit("transactionSendFailed", t13);
    }), this.transactionWorker.on("transactionExecuted", async (t13) => {
      this.emit("transactionExecuted", t13);
    }), this.transactionWorker.on("transactionExecutionFailed", async (t13) => {
      this.emit("transactionExecutionFailed", t13);
    }), this.transactionWorker.on("executionFinish", async (t13) => {
      this.emit("executionFinish", t13);
    });
  }
  forSingleAccount(t13) {
    try {
      let { sender: n24, data: o13, options: r23 } = t13;
      this.start({ sender: n24 }), this.push({ data: o13, options: r23 });
    } catch (n24) {
      throw new Error(`failed to submit transactions with error: ${n24}`);
    }
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6EMN3BOV.mjs
function o12(a13, i48, e3) {
  let r23 = e3.value;
  return e3.value = async function(...t13) {
    let [n24] = t13;
    if (n24.transaction.feePayerAddress && !n24.feePayerAuthenticator)
      throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
    return r23.apply(this, t13);
  }, e3;
}
function u6(a13, i48, e3) {
  let r23 = e3.value;
  return e3.value = async function(...t13) {
    let [n24] = t13;
    if (n24.transaction.feePayerAddress && !n24.feePayerPublicKey)
      throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
    return r23.apply(this, t13);
  }, e3;
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CX5ULWJQ.mjs
var i46 = class {
  constructor(n24) {
    this.config = n24;
  }
  async simple(n24) {
    return $4({ aptosConfig: this.config, ...n24 });
  }
  async multiAgent(n24) {
    return $4({ aptosConfig: this.config, ...n24 });
  }
};
j([u6], i46.prototype, "simple", 1), j([u6], i46.prototype, "multiAgent", 1);

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GVHOHNHT.mjs
var n21 = class {
  constructor(t13) {
    this.config = t13;
  }
  async simple(t13) {
    return B4({ aptosConfig: this.config, ...t13 });
  }
  async multiAgent(t13) {
    return B4({ aptosConfig: this.config, ...t13 });
  }
};
j([o12], n21.prototype, "simple", 1), j([o12], n21.prototype, "multiAgent", 1);

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WK36MJRI.mjs
var h11 = class {
  constructor(n24) {
    this.config = n24, this.build = new o11(this.config), this.simulate = new i46(this.config), this.submit = new n21(this.config), this.batch = new i45(this.config);
  }
  async getTransactions(n24) {
    return F({ aptosConfig: this.config, ...n24 });
  }
  async getTransactionByVersion(n24) {
    return v2({ aptosConfig: this.config, ...n24 });
  }
  async getTransactionByHash(n24) {
    return x2({ aptosConfig: this.config, ...n24 });
  }
  async isPendingTransaction(n24) {
    return N2({ aptosConfig: this.config, ...n24 });
  }
  async waitForTransaction(n24) {
    return G2({ aptosConfig: this.config, ...n24 });
  }
  async getGasPriceEstimation() {
    return L({ aptosConfig: this.config });
  }
  getSigningMessage(n24) {
    return Y(n24);
  }
  async publishPackageTransaction(n24) {
    return nn({ aptosConfig: this.config, ...n24 });
  }
  async rotateAuthKey(n24) {
    return tn2({ aptosConfig: this.config, ...n24 });
  }
  sign(n24) {
    return K2({ ...n24 });
  }
  signAsFeePayer(n24) {
    let { signer: t13, transaction: a13 } = n24;
    if (!a13.feePayerAddress)
      throw new Error(`Transaction ${a13} is not a Fee Payer transaction`);
    return a13.feePayerAddress = t13.accountAddress, K2({ signer: t13, transaction: a13 });
  }
  async batchTransactionsForSingleAccount(n24) {
    try {
      let { sender: t13, data: a13, options: P6 } = n24;
      this.batch.forSingleAccount({ sender: t13, data: a13, options: P6 });
    } catch (t13) {
      throw new Error(`failed to submit transactions with error: ${t13}`);
    }
  }
  async signAndSubmitTransaction(n24) {
    let { signer: t13, transaction: a13 } = n24;
    return M3({ aptosConfig: this.config, signer: t13, transaction: a13 });
  }
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i48;
  let l12;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i48 = 0, l12 = obj.length; i48 < l12; i48++) {
      fn.call(null, obj[i48], i48, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i48 = 0; i48 < len; i48++) {
      key = keys[i48];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i48 = keys.length;
  let _key;
  while (i48-- > 0) {
    _key = keys[i48];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i48 = 0, l12 = arguments.length; i48 < l12; i48++) {
    arguments[i48] && forEach(arguments[i48], assignValue);
  }
  return result;
}
var extend = (a13, b9, thisArg, { allOwnKeys } = {}) => {
  forEach(b9, (val, key) => {
    if (thisArg && isFunction(val)) {
      a13[key] = bind(val, thisArg);
    } else {
      a13[key] = val;
    }
  }, { allOwnKeys });
  return a13;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i48;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i48 = props.length;
    while (i48-- > 0) {
      prop = props[i48];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i48 = thing.length;
  if (!isNumber(i48))
    return null;
  const arr = new Array(i48);
  while (i48-- > 0) {
    arr[i48] = thing[i48];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m12, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i48) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i48] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i48 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i48] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i48) {
    token = removeBrackets(token);
    return !dots && i48 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h14) {
      if (h14 !== null) {
        fn(h14);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/common/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports2,
  ...browser_default
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i48;
  const len = keys.length;
  let key;
  for (i48 = 0; i48 < len; i48++) {
    key = keys[i48];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError_default.from(e3, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i48;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i48 = line.indexOf(":");
    key = line.substring(0, i48).trim().toLowerCase();
    val = line.substring(i48 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w5, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i48 = keys.length;
    let deleted = false;
    while (i48--) {
      const key = keys[i48];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i48 = tail;
    let bytesCount = 0;
    while (i48 !== head) {
      bytesCount += bytes2[i48++];
      i48 = i48 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e3
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e3) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i48 = 0; i48 < length; i48++) {
      nameOrAdapter = adapters[i48];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i48] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s12 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s12,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a13, b9, caseless) {
    if (!utils_default.isUndefined(b9)) {
      return getMergedValue(a13, b9, caseless);
    } else if (!utils_default.isUndefined(a13)) {
      return getMergedValue(void 0, a13, caseless);
    }
  }
  function valueFromConfig2(a13, b9) {
    if (!utils_default.isUndefined(b9)) {
      return getMergedValue(void 0, b9);
    }
  }
  function defaultToConfig2(a13, b9) {
    if (!utils_default.isUndefined(b9)) {
      return getMergedValue(void 0, b9);
    } else if (!utils_default.isUndefined(a13)) {
      return getMergedValue(void 0, a13);
    }
  }
  function mergeDirectKeys(a13, b9, prop) {
    if (prop in config2) {
      return getMergedValue(a13, b9);
    } else if (prop in config1) {
      return getMergedValue(void 0, a13);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a13, b9) => mergeDeepProperties(headersToObject(a13), headersToObject(b9), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/env/data.js
var VERSION = "1.6.2";

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i48) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i48 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i48 = keys.length;
  while (i48-- > 0) {
    const opt = keys[i48];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i48 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i48 < len) {
        promise = promise.then(chain2[i48++], chain2[i48++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i48 = 0;
    while (i48 < len) {
      const onFulfilled = requestInterceptorChain[i48++];
      const onRejected = requestInterceptorChain[i48++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i48 = 0;
    len = responseInterceptorChain.length;
    while (i48 < len) {
      promise = promise.then(responseInterceptorChain[i48++], responseInterceptorChain[i48++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i48 = token._listeners.length;
      while (i48-- > 0) {
        token._listeners[i48](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c14) {
      cancel = c14;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/.pnpm/axios@1.6.2/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/.pnpm/@aptos-labs+aptos-client@0.1.0/node_modules/@aptos-labs/aptos-client/dist/browser/index.browser.mjs
async function aptosClient(options) {
  var _a;
  const { params, method, url, headers, body, overrides } = options;
  const requestConfig = {
    headers,
    method,
    url,
    params,
    data: body,
    withCredentials: (_a = overrides == null ? void 0 : overrides.WITH_CREDENTIALS) != null ? _a : true
  };
  try {
    const response = await axios_default(requestConfig);
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers,
      config: response.config
    };
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CCUD52OF.mjs
var i47 = class {
  constructor(e3) {
    this.network = (e3 == null ? void 0 : e3.network) ?? n5, this.fullnode = e3 == null ? void 0 : e3.fullnode, this.faucet = e3 == null ? void 0 : e3.faucet, this.indexer = e3 == null ? void 0 : e3.indexer, this.client = (e3 == null ? void 0 : e3.client) ?? { provider: aptosClient }, this.clientConfig = (e3 == null ? void 0 : e3.clientConfig) ?? {};
  }
  getRequestUrl(e3) {
    switch (e3) {
      case 0:
        if (this.fullnode !== void 0)
          return this.fullnode;
        if (this.network === "custom")
          throw new Error("Please provide a custom full node url");
        return o10[this.network];
      case 2:
        if (this.faucet !== void 0)
          return this.faucet;
        if (this.network === "custom")
          throw new Error("Please provide a custom faucet url");
        return a11[this.network];
      case 1:
        if (this.indexer !== void 0)
          return this.indexer;
        if (this.network === "custom")
          throw new Error("Please provide a custom indexer url");
        return n18[this.network];
      default:
        throw Error(`apiType ${e3} is not supported`);
    }
  }
  isIndexerRequest(e3) {
    return n18[this.network] === e3;
  }
  isFullnodeRequest(e3) {
    return o10[this.network] === e3;
  }
  isFaucetRequest(e3) {
    return a11[this.network] === e3;
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6Y3VBRMN.mjs
var u7 = { typeParameters: [{ constraints: [] }], parameters: [new S2(), new p5()] };
async function y7(e3) {
  let { aptosConfig: i48, sender: s12, recipient: c14, amount: a13, coinType: p12, options: m12 } = e3;
  return h10({ aptosConfig: i48, sender: s12, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [p12 ?? A6], functionArguments: [c14, a13], abi: u7 }, options: m12 });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ESX5X52V.mjs
var t11 = class {
  constructor(n24) {
    this.config = n24;
  }
  async transferCoinTransaction(n24) {
    return y7({ aptosConfig: this.config, ...n24 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-INV6U3KS.mjs
var C3 = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
var m10 = "0x4::token::Token";
async function Pt(t13) {
  let { aptosConfig: o13, digitalAssetAddress: n24 } = t13, e3 = { token_data_id: { _eq: c.from(n24).toStringLong() } };
  return (await p3({ aptosConfig: o13, query: { query: Q, variables: { where_condition: e3 } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function _t(t13) {
  let { aptosConfig: o13, digitalAssetAddress: n24 } = t13, e3 = { token_data_id: { _eq: c.from(n24).toStringLong() } };
  return (await p3({ aptosConfig: o13, query: { query: q, variables: { where_condition: e3 } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function kt(t13) {
  let { aptosConfig: o13, ownerAddress: n24, options: e3 } = t13, r23 = { owner_address: { _eq: c.from(n24).toStringLong() }, amount: { _gt: 0 } }, i48 = { query: q, variables: { where_condition: r23, offset: e3 == null ? void 0 : e3.offset, limit: e3 == null ? void 0 : e3.limit, order_by: e3 == null ? void 0 : e3.orderBy } };
  return (await p3({ aptosConfig: o13, query: i48, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function Dt(t13) {
  let { aptosConfig: o13, digitalAssetAddress: n24, options: e3 } = t13, r23 = { token_data_id: { _eq: c.from(n24).toStringLong() } }, i48 = { query: C, variables: { where_condition: r23, offset: e3 == null ? void 0 : e3.offset, limit: e3 == null ? void 0 : e3.limit, order_by: e3 == null ? void 0 : e3.orderBy } };
  return (await p3({ aptosConfig: o13, query: i48, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var U9 = { typeParameters: [], parameters: [new b2(V()), new p5(), new b2(V()), new b2(V()), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new p5(), new p5()] };
async function St(t13) {
  let { aptosConfig: o13, options: n24, creator: e3 } = t13;
  return h10({ aptosConfig: o13, sender: e3.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a3(t13.description), new m6(t13.maxSupply ?? _), new a3(t13.name), new a3(t13.uri), new U3(t13.mutableDescription ?? true), new U3(t13.mutableRoyalty ?? true), new U3(t13.mutableURI ?? true), new U3(t13.mutableTokenDescription ?? true), new U3(t13.mutableTokenName ?? true), new U3(t13.mutableTokenProperties ?? true), new U3(t13.mutableTokenURI ?? true), new U3(t13.tokensBurnableByCreator ?? true), new U3(t13.tokensFreezableByCreator ?? true), new m6(t13.royaltyNumerator ?? 0), new m6(t13.royaltyDenominator ?? 1)], abi: U9 }, options: n24 });
}
async function F3(t13) {
  let { aptosConfig: o13, creatorAddress: n24, collectionName: e3, options: r23 } = t13, i48 = c.from(n24), a13 = { collection_name: { _eq: e3 }, creator_address: { _eq: i48.toStringLong() } };
  return (r23 == null ? void 0 : r23.tokenStandard) && (a13.token_standard = { _eq: (r23 == null ? void 0 : r23.tokenStandard) ?? "v2" }), (await p3({ aptosConfig: o13, query: { query: T, variables: { where_condition: a13 } }, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function vt(t13) {
  return (await F3(t13)).collection_id;
}
var Q3 = { typeParameters: [], parameters: [new b2(V()), new b2(V()), new b2(V()), new b2(V()), new y2(new b2(V())), new y2(new b2(V())), new y2(y2.u8())] };
async function xt(t13) {
  let { aptosConfig: o13, options: n24, creator: e3, collection: r23, description: i48, name: a13, uri: l12, propertyKeys: y10, propertyTypes: _5, propertyValues: P6 } = t13, k3 = _5 == null ? void 0 : _5.map((D8) => C3[D8]);
  return h10({ aptosConfig: o13, sender: e3.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a3(r23), new a3(i48), new a3(a13), new a3(l12), t6.MoveString(y10 ?? []), t6.MoveString(k3 ?? []), K3(P6 ?? [], k3 ?? [])], abi: Q3 }, options: n24 });
}
var N6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new S2()] };
async function ht(t13) {
  let { aptosConfig: o13, sender: n24, digitalAssetAddress: e3, recipient: r23, digitalAssetType: i48, options: a13 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [i48 ?? m10], functionArguments: [c.from(e3), c.from(r23)], abi: N6 }, options: a13 });
}
var Y2 = { typeParameters: [], parameters: [new b2(V()), new b2(V()), new b2(V()), new b2(V()), new y2(new b2(V())), new y2(new b2(V())), new y2(y2.u8()), new S2()] };
async function Gt(t13) {
  let { aptosConfig: o13, account: n24, collection: e3, description: r23, name: i48, uri: a13, recipient: l12, propertyKeys: y10, propertyTypes: _5, propertyValues: P6, options: k3 } = t13;
  if ((y10 == null ? void 0 : y10.length) !== (P6 == null ? void 0 : P6.length))
    throw new Error("Property keys and property values counts do not match");
  if ((_5 == null ? void 0 : _5.length) !== (P6 == null ? void 0 : P6.length))
    throw new Error("Property types and property values counts do not match");
  let D8 = _5 == null ? void 0 : _5.map((R4) => C3[R4]);
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [e3, r23, i48, a13, t6.MoveString(y10 ?? []), t6.MoveString(D8 ?? []), K3(P6 ?? [], D8 ?? []), l12], abi: Y2 }, options: k3 });
}
var z3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0)))] };
async function Bt(t13) {
  let { aptosConfig: o13, creator: n24, digitalAssetAddress: e3, digitalAssetType: r23, options: i48 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [r23 ?? m10], functionArguments: [c.from(e3)], abi: z3 }, options: i48 });
}
var L3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0)))] };
async function Ot(t13) {
  let { aptosConfig: o13, creator: n24, digitalAssetAddress: e3, digitalAssetType: r23, options: i48 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [r23 ?? m10], functionArguments: [e3], abi: L3 }, options: i48 });
}
var j3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0)))] };
async function Et(t13) {
  let { aptosConfig: o13, creator: n24, digitalAssetAddress: e3, digitalAssetType: r23, options: i48 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [r23 ?? m10], functionArguments: [e3], abi: j3 }, options: i48 });
}
var X2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V())] };
async function Vt(t13) {
  let { aptosConfig: o13, creator: n24, description: e3, digitalAssetAddress: r23, digitalAssetType: i48, options: a13 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [i48 ?? m10], functionArguments: [c.from(r23), new a3(e3)], abi: X2 }, options: a13 });
}
var H = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V())] };
async function Mt(t13) {
  let { aptosConfig: o13, creator: n24, name: e3, digitalAssetAddress: r23, digitalAssetType: i48, options: a13 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [i48 ?? m10], functionArguments: [c.from(r23), new a3(e3)], abi: H }, options: a13 });
}
var J = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V())] };
async function qt(t13) {
  let { aptosConfig: o13, creator: n24, uri: e3, digitalAssetAddress: r23, digitalAssetType: i48, options: a13 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [i48 ?? m10], functionArguments: [c.from(r23), new a3(e3)], abi: J }, options: a13 });
}
var W2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V()), new b2(V()), y2.u8()] };
async function Kt(t13) {
  let { aptosConfig: o13, creator: n24, propertyKey: e3, propertyType: r23, propertyValue: i48, digitalAssetAddress: a13, digitalAssetType: l12, options: y10 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [l12 ?? m10], functionArguments: [c.from(a13), new a3(e3), new a3(C3[r23]), t6.U8(G7(i48, C3[r23]))], abi: W2 }, options: y10 });
}
var Z3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V())] };
async function Rt(t13) {
  let { aptosConfig: o13, creator: n24, propertyKey: e3, digitalAssetAddress: r23, digitalAssetType: i48, options: a13 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [i48 ?? m10], functionArguments: [c.from(r23), new a3(e3)], abi: Z3 }, options: a13 });
}
var $5 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(G3(new h5(0))), new b2(V()), new b2(V()), y2.u8()] };
async function Ut(t13) {
  let { aptosConfig: o13, creator: n24, propertyKey: e3, propertyType: r23, propertyValue: i48, digitalAssetAddress: a13, digitalAssetType: l12, options: y10 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [l12 ?? m10], functionArguments: [c.from(a13), new a3(e3), new a3(C3[r23]), G7(i48, C3[r23])], abi: $5 }, options: y10 });
}
var tt = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b2(G3(new h5(0))), new b2(V()), new h5(1)] };
async function Ft(t13) {
  let { aptosConfig: o13, creator: n24, propertyKey: e3, propertyType: r23, propertyValue: i48, digitalAssetAddress: a13, digitalAssetType: l12, options: y10 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [l12 ?? m10, C3[r23]], functionArguments: [c.from(a13), new a3(e3), i48], abi: tt }, options: y10 });
}
var et = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b2(G3(new h5(0))), new b2(V()), new h5(1)] };
async function Qt(t13) {
  let { aptosConfig: o13, creator: n24, propertyKey: e3, propertyType: r23, propertyValue: i48, digitalAssetAddress: a13, digitalAssetType: l12, options: y10 } = t13;
  return h10({ aptosConfig: o13, sender: n24.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [l12 ?? m10, C3[r23]], functionArguments: [c.from(a13), new a3(e3), i48], abi: et }, options: y10 });
}
function K3(t13, o13) {
  let n24 = new Array();
  return o13.forEach((e3, r23) => {
    n24.push(G7(t13[r23], e3));
  }), n24;
}
function G7(t13, o13) {
  let n24 = Z(o13);
  return U6(t13, n24, 0, []).bcsToBytes();
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4SAUEZTN.mjs
var D6 = class {
  constructor(t13) {
    this.config = t13;
  }
  async getCollectionData(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), F3({ aptosConfig: this.config, ...t13 });
  }
  async getCollectionId(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), vt({ aptosConfig: this.config, ...t13 });
  }
  async getDigitalAssetData(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), Pt({ aptosConfig: this.config, ...t13 });
  }
  async getCurrentDigitalAssetOwnership(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), _t({ aptosConfig: this.config, ...t13 });
  }
  async getOwnedDigitalAssets(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), kt({ aptosConfig: this.config, ...t13 });
  }
  async getDigitalAssetActivity(t13) {
    return await i5({ config: this.config, minimumLedgerVersion: t13.minimumLedgerVersion, processorType: "token_v2_processor" }), Dt({ aptosConfig: this.config, ...t13 });
  }
  async createCollectionTransaction(t13) {
    return St({ aptosConfig: this.config, ...t13 });
  }
  async mintDigitalAssetTransaction(t13) {
    return xt({ aptosConfig: this.config, ...t13 });
  }
  async transferDigitalAssetTransaction(t13) {
    return ht({ aptosConfig: this.config, ...t13 });
  }
  async mintSoulBoundTransaction(t13) {
    return Gt({ aptosConfig: this.config, ...t13 });
  }
  async burnDigitalAssetTransaction(t13) {
    return Bt({ aptosConfig: this.config, ...t13 });
  }
  async freezeDigitalAssetTransaferTransaction(t13) {
    return Ot({ aptosConfig: this.config, ...t13 });
  }
  async unfreezeDigitalAssetTransaferTransaction(t13) {
    return Et({ aptosConfig: this.config, ...t13 });
  }
  async setDigitalAssetDescriptionTransaction(t13) {
    return Vt({ aptosConfig: this.config, ...t13 });
  }
  async setDigitalAssetNameTransaction(t13) {
    return Mt({ aptosConfig: this.config, ...t13 });
  }
  async setDigitalAssetURITransaction(t13) {
    return qt({ aptosConfig: this.config, ...t13 });
  }
  async addDigitalAssetPropertyTransaction(t13) {
    return Kt({ aptosConfig: this.config, ...t13 });
  }
  async removeDigitalAssetPropertyTransaction(t13) {
    return Rt({ aptosConfig: this.config, ...t13 });
  }
  async updateDigitalAssetPropertyTransaction(t13) {
    return Ut({ aptosConfig: this.config, ...t13 });
  }
  async addDigitalAssetTypedPropertyTransaction(t13) {
    return Ft({ aptosConfig: this.config, ...t13 });
  }
  async updateDigitalAssetTypedPropertyTransaction(t13) {
    return Qt({ aptosConfig: this.config, ...t13 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AA3GRJNL.mjs
async function f11(t13) {
  let { accountAddress: n24, aptosConfig: e3, creationNumber: s12, options: o13 } = t13, r23 = { where: { account_address: { _eq: c.from(n24).toStringLong() }, creation_number: { _eq: s12 } }, pagination: o13, orderBy: o13 == null ? void 0 : o13.orderBy };
  return c11({ aptosConfig: e3, options: r23 });
}
async function v6(t13) {
  let { accountAddress: n24, aptosConfig: e3, eventType: s12, options: o13 } = t13, r23 = { where: { account_address: { _eq: c.from(n24).toStringLong() }, indexed_type: { _eq: s12 } }, pagination: o13, orderBy: o13 == null ? void 0 : o13.orderBy };
  return c11({ aptosConfig: e3, options: r23 });
}
async function c11(t13) {
  let { aptosConfig: n24, options: e3 } = t13, s12 = { query: f, variables: { where_condition: e3 == null ? void 0 : e3.where, offset: e3 == null ? void 0 : e3.offset, limit: e3 == null ? void 0 : e3.limit, order_by: e3 == null ? void 0 : e3.orderBy } };
  return (await p3({ aptosConfig: n24, query: s12, originMethod: "getEvents" })).events;
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZIZ7PVK2.mjs
var s11 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getAccountEventsByCreationNumber(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "events_processor" }), f11({ aptosConfig: this.config, ...e3 });
  }
  async getAccountEventsByEventType(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "events_processor" }), v6({ aptosConfig: this.config, ...e3 });
  }
  async getEvents(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "events_processor" }), c11({ aptosConfig: this.config, ...e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UJAX75ON.mjs
async function x5(a13) {
  let { aptosConfig: t13, accountAddress: i48, amount: p12, options: n24 } = a13, u10 = (n24 == null ? void 0 : n24.timeoutSecs) || T4, { data: d9 } = await x({ aptosConfig: t13, path: "fund", body: { address: c.from(i48).toString(), amount: p12 }, originMethod: "fundAccount" }), m12 = d9.txn_hashes[0], o13 = await G2({ aptosConfig: t13, transactionHash: m12, options: { timeoutSecs: u10, checkSuccess: n24 == null ? void 0 : n24.checkSuccess } });
  if (o13.type === "user_transaction")
    return o13;
  throw new Error(`Unexpected transaction received for fund account: ${o13.type}`);
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Q7JKS6WV.mjs
var r21 = class {
  constructor(o13) {
    this.config = o13;
  }
  async fundAccount(o13) {
    var _a;
    let n24 = await x5({ aptosConfig: this.config, ...o13 });
    return ((_a = o13.options) == null ? void 0 : _a.waitForIndexer) !== false && await D({ aptosConfig: this.config, minimumLedgerVersion: BigInt(n24.version) }), n24;
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TVURQPLA.mjs
async function h12(t13) {
  let { aptosConfig: s12, options: e3 } = t13, n24 = { query: h3, variables: { where_condition: e3 == null ? void 0 : e3.where, limit: e3 == null ? void 0 : e3.limit, offset: e3 == null ? void 0 : e3.offset } };
  return (await p3({ aptosConfig: s12, query: n24, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function M4(t13) {
  let { aptosConfig: s12, options: e3 } = t13, n24 = { query: v, variables: { where_condition: e3 == null ? void 0 : e3.where, limit: e3 == null ? void 0 : e3.limit, offset: e3 == null ? void 0 : e3.offset } };
  return (await p3({ aptosConfig: s12, query: n24, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function x6(t13) {
  let { aptosConfig: s12, options: e3 } = t13, n24 = { query: k, variables: { where_condition: e3 == null ? void 0 : e3.where, limit: e3 == null ? void 0 : e3.limit, offset: e3 == null ? void 0 : e3.offset } };
  return (await p3({ aptosConfig: s12, query: n24, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var b6 = { typeParameters: [], parameters: [Z("0x1::object::Object"), new S2(), new p5()] };
async function v7(t13) {
  let { aptosConfig: s12, sender: e3, fungibleAssetMetadataAddress: n24, recipient: i48, amount: p12, options: f13 } = t13;
  return h10({ aptosConfig: s12, sender: e3.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [n24, i48, p12], abi: b6 }, options: f13 });
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-C7ZX475J.mjs
var r22 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getFungibleAssetMetadata(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), h12({ aptosConfig: this.config, ...e3 });
  }
  async getFungibleAssetMetadataByAssetType(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await h12({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e3.assetType } } } }))[0];
  }
  async getFungibleAssetActivities(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), M4({ aptosConfig: this.config, ...e3 });
  }
  async getCurrentFungibleAssetBalances(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3 == null ? void 0 : e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), x6({ aptosConfig: this.config, ...e3 });
  }
  async transferFungibleAsset(e3) {
    return v7({ aptosConfig: this.config, ...e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZFPA45OK.mjs
var u8 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getLedgerInfo() {
    return l4({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(e3) {
    return h4({ aptosConfig: this.config, ...e3 });
  }
  async getBlockByHeight(e3) {
    return m2({ aptosConfig: this.config, ...e3 });
  }
  async getTableItem(e3) {
    return C2({ aptosConfig: this.config, ...e3 });
  }
  async view(e3) {
    return T3({ aptosConfig: this.config, ...e3 });
  }
  async getChainTopUserTransactions(e3) {
    return q2({ aptosConfig: this.config, ...e3 });
  }
  async queryIndexer(e3) {
    return p3({ aptosConfig: this.config, ...e3 });
  }
  async getIndexerLastSuccessVersion() {
    return w3({ aptosConfig: this.config });
  }
  async getProcessorStatus(e3) {
    return A4({ aptosConfig: this.config, processorType: e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WQI2RH2S.mjs
var l10 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getAccountInfo(e3) {
    return M2({ aptosConfig: this.config, ...e3 });
  }
  async getAccountModules(e3) {
    return io({ aptosConfig: this.config, ...e3 });
  }
  async getAccountModule(e3) {
    return uo({ aptosConfig: this.config, ...e3 });
  }
  async getAccountTransactions(e3) {
    return go({ aptosConfig: this.config, ...e3 });
  }
  async getAccountResources(e3) {
    return Ao({ aptosConfig: this.config, ...e3 });
  }
  async getAccountResource(e3) {
    return K({ aptosConfig: this.config, ...e3 });
  }
  async lookupOriginalAccountAddress(e3) {
    return Q2({ aptosConfig: this.config, ...e3 });
  }
  async getAccountTokensCount(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "account_transactions_processor" }), po({ aptosConfig: this.config, ...e3 });
  }
  async getAccountOwnedTokens(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "token_v2_processor" }), fo({ aptosConfig: this.config, ...e3 });
  }
  async getAccountOwnedTokensFromCollectionAddress(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "token_v2_processor" }), lo({ aptosConfig: this.config, ...e3 });
  }
  async getAccountCollectionsWithOwnedTokens(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "token_v2_processor" }), yo({ aptosConfig: this.config, ...e3 });
  }
  async getAccountTransactionsCount(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "account_transactions_processor" }), mo({ aptosConfig: this.config, ...e3 });
  }
  async getAccountCoinsData(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), I2({ aptosConfig: this.config, ...e3 });
  }
  async getAccountCoinsCount(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Co({ aptosConfig: this.config, ...e3 });
  }
  async getAccountAPTAmount(e3) {
    return this.getAccountCoinAmount({ coinType: A6, ...e3 });
  }
  async getAccountCoinAmount(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "fungible_asset_processor" }), _o({ aptosConfig: this.config, ...e3 });
  }
  async getAccountOwnedObjects(e3) {
    return await i5({ config: this.config, minimumLedgerVersion: e3.minimumLedgerVersion, processorType: "default_processor" }), ho({ aptosConfig: this.config, ...e3 });
  }
  async deriveAccountFromPrivateKey(e3) {
    return wo({ aptosConfig: this.config, ...e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3NOQE6U3.mjs
var E4 = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function D7(e3) {
  return !(!e3 || e3.length < 3 || e3.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(e3));
}
function c12(e3) {
  let [n24, t13, ...o13] = e3.replace(/\.apt$/, "").split(".");
  if (o13.length > 0)
    throw new Error(`${e3} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!D7(n24))
    throw new Error(`${n24} is not valid. ${E4}`);
  if (t13 && !D7(t13))
    throw new Error(`${t13} is not valid. ${E4}`);
  return { domainName: t13 || n24, subdomainName: t13 ? n24 : void 0 };
}
var G8 = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
var O = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: G8, custom: null, devnet: null, randomnet: null };
function d7(e3) {
  let n24 = O[e3.network];
  if (!n24)
    throw new Error(`The ANS contract is not deployed to ${e3.network}`);
  return n24;
}
var P4 = (e3) => ({ vec: [e3] });
var I4 = () => ({ vec: [] });
var S6 = (e3) => e3 != null ? P4(e3) : I4();
var b7 = (e3) => {
  if (e3 && typeof e3 == "object" && "vec" in e3 && Array.isArray(e3.vec))
    return e3.vec[0];
};
async function K4(e3) {
  let { aptosConfig: n24, name: t13 } = e3, o13 = d7(n24), { domainName: r23, subdomainName: s12 } = c12(t13), i48 = await T3({ aptosConfig: n24, payload: { function: `${o13}::router::get_owner_addr`, functionArguments: [r23, S6(s12)] } }), a13 = b7(i48[0]);
  return a13 ? c.from(a13).toString() : void 0;
}
async function W3(e3) {
  let { aptosConfig: n24, expiration: t13, name: o13, sender: r23, targetAddress: s12, toAddress: i48, options: a13, transferable: m12 } = e3, p12 = d7(n24), { domainName: l12, subdomainName: N7 } = c12(o13), x8 = t13.policy === "subdomain:independent" || t13.policy === "subdomain:follow-domain";
  if (N7 && !x8)
    throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (x8 && !N7)
    throw new Error(`Policy is set to ${t13.policy} but no subdomain was provided`);
  if (t13.policy === "domain") {
    let T10 = t13.years ?? 1;
    if (T10 !== 1)
      throw new Error("For now, names can only be registered for 1 year at a time");
    let v9 = T10 * 31536e3;
    return await h10({ aptosConfig: n24, sender: r23.accountAddress.toString(), data: { function: `${p12}::router::register_domain`, functionArguments: [l12, v9, s12, i48] }, options: a13 });
  }
  if (!N7)
    throw new Error(`${t13.policy} requires a subdomain to be provided.`);
  let _5 = await q3({ aptosConfig: n24, name: l12 });
  if (!_5)
    throw new Error("The domain does not exist");
  let h14 = t13.policy === "subdomain:independent" ? t13.expirationDate : _5;
  if (h14 > _5)
    throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await h10({ aptosConfig: n24, sender: r23.accountAddress.toString(), data: { function: `${p12}::router::register_subdomain`, functionArguments: [l12, N7, Math.round(h14 / 1e3), t13.policy === "subdomain:follow-domain" ? 1 : 0, !!m12, s12, i48] }, options: a13 });
}
async function q3(e3) {
  let { aptosConfig: n24, name: t13 } = e3, o13 = d7(n24), { domainName: r23, subdomainName: s12 } = c12(t13);
  try {
    let i48 = await T3({ aptosConfig: n24, payload: { function: `${o13}::router::get_expiration`, functionArguments: [r23, S6(s12)] } });
    return Number(i48[0]) * 1e3;
  } catch {
    return;
  }
}
async function F4(e3) {
  let { aptosConfig: n24, address: t13 } = e3, o13 = d7(n24), r23 = await T3({ aptosConfig: n24, payload: { function: `${o13}::router::get_primary_name`, functionArguments: [c.from(t13).toString()] } }), s12 = b7(r23[1]), i48 = b7(r23[0]);
  if (s12)
    return [i48, s12].filter(Boolean).join(".");
}
async function H2(e3) {
  let { aptosConfig: n24, sender: t13, name: o13, options: r23 } = e3, s12 = d7(n24);
  if (!o13)
    return await h10({ aptosConfig: n24, sender: t13.accountAddress.toString(), data: { function: `${s12}::router::clear_primary_name`, functionArguments: [] }, options: r23 });
  let { domainName: i48, subdomainName: a13 } = c12(o13);
  return await h10({ aptosConfig: n24, sender: t13.accountAddress.toString(), data: { function: `${s12}::router::set_primary_name`, functionArguments: [i48, a13] }, options: r23 });
}
async function J2(e3) {
  let { aptosConfig: n24, name: t13 } = e3, o13 = d7(n24), { domainName: r23, subdomainName: s12 } = c12(t13), i48 = await T3({ aptosConfig: n24, payload: { function: `${o13}::router::get_target_addr`, functionArguments: [r23, S6(s12)] } }), a13 = b7(i48[0]);
  return a13 ? c.from(a13).toString() : void 0;
}
async function X3(e3) {
  let { aptosConfig: n24, sender: t13, name: o13, address: r23, options: s12 } = e3, i48 = d7(n24), { domainName: a13, subdomainName: m12 } = c12(o13);
  return await h10({ aptosConfig: n24, sender: t13.accountAddress.toString(), data: { function: `${i48}::router::set_target_addr`, functionArguments: [a13, m12, r23] }, options: s12 });
}
async function Z4(e3) {
  let { aptosConfig: n24, name: t13 } = e3, { domainName: o13, subdomainName: r23 = "" } = c12(t13), a13 = (await p3({ aptosConfig: n24, query: { query: A2, variables: { where_condition: { domain: { _eq: o13 }, subdomain: { _eq: r23 } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return a13 && (a13 = y8(a13)), a13;
}
async function ee(e3) {
  var _a;
  let { aptosConfig: n24, options: t13, accountAddress: o13 } = e3, r23 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountNames", query: { query: A2, variables: { limit: t13 == null ? void 0 : t13.limit, offset: t13 == null ? void 0 : t13.offset, order_by: t13 == null ? void 0 : t13.orderBy, where_condition: { ...((_a = e3.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o13.toString() }, expiration_timestamp: { _gte: r23 } } } } })).current_aptos_names.map(y8);
}
async function ne(e3) {
  var _a;
  let { aptosConfig: n24, options: t13, accountAddress: o13 } = e3, r23 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountDomains", query: { query: A2, variables: { limit: t13 == null ? void 0 : t13.limit, offset: t13 == null ? void 0 : t13.offset, order_by: t13 == null ? void 0 : t13.orderBy, where_condition: { ...((_a = e3.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o13.toString() }, expiration_timestamp: { _gte: r23 }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(y8);
}
async function te(e3) {
  var _a;
  let { aptosConfig: n24, options: t13, accountAddress: o13 } = e3, r23 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountSubdomains", query: { query: A2, variables: { limit: t13 == null ? void 0 : t13.limit, offset: t13 == null ? void 0 : t13.offset, order_by: t13 == null ? void 0 : t13.orderBy, where_condition: { ...((_a = e3.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o13.toString() }, expiration_timestamp: { _gte: r23 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y8);
}
async function oe(e3) {
  var _a;
  let { aptosConfig: n24, options: t13, domain: o13 } = e3;
  return (await p3({ aptosConfig: n24, originMethod: "getDomainSubdomains", query: { query: A2, variables: { limit: t13 == null ? void 0 : t13.limit, offset: t13 == null ? void 0 : t13.offset, order_by: t13 == null ? void 0 : t13.orderBy, where_condition: { ...((_a = e3.options) == null ? void 0 : _a.where) ?? {}, domain: { _eq: o13 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y8);
}
async function C4(e3) {
  let { aptosConfig: n24 } = e3, t13 = d7(n24), [o13] = await T3({ aptosConfig: n24, payload: { function: `${t13}::config::reregistration_grace_sec`, functionArguments: [] } }), r23 = o13 / 60 / 60 / 24, s12 = () => /* @__PURE__ */ new Date();
  return new Date(s12().setDate(s12().getDate() - r23)).toISOString();
}
async function re(e3) {
  let { aptosConfig: n24, sender: t13, name: o13, years: r23 = 1, options: s12 } = e3, i48 = d7(n24), a13 = r23 * 31536e3, { domainName: m12, subdomainName: p12 } = c12(o13);
  if (p12)
    throw new Error("Subdomains cannot be renewed");
  if (r23 !== 1)
    throw new Error("Currently, only 1 year renewals are supported");
  return await h10({ aptosConfig: n24, sender: t13.accountAddress.toString(), data: { function: `${i48}::router::renew_domain`, functionArguments: [m12, a13] }, options: s12 });
}
function y8(e3) {
  return { ...e3, expiration_timestamp: new Date(e3.expiration_timestamp).valueOf() };
}

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5WXR2O3T.mjs
var A11 = class {
  constructor(e3) {
    this.config = e3;
  }
  async getOwnerAddress(e3) {
    return K4({ aptosConfig: this.config, ...e3 });
  }
  async getExpiration(e3) {
    return q3({ aptosConfig: this.config, ...e3 });
  }
  async getTargetAddress(e3) {
    return J2({ aptosConfig: this.config, ...e3 });
  }
  async setTargetAddress(e3) {
    return X3({ aptosConfig: this.config, ...e3 });
  }
  async getPrimaryName(e3) {
    return F4({ aptosConfig: this.config, ...e3 });
  }
  async setPrimaryName(e3) {
    return H2({ aptosConfig: this.config, ...e3 });
  }
  async registerName(e3) {
    return W3({ aptosConfig: this.config, ...e3 });
  }
  async renewDomain(e3) {
    return re({ aptosConfig: this.config, ...e3 });
  }
  async getName(e3) {
    return Z4({ aptosConfig: this.config, ...e3 });
  }
  async getAccountNames(e3) {
    return ee({ aptosConfig: this.config, ...e3 });
  }
  async getAccountDomains(e3) {
    return ne({ aptosConfig: this.config, ...e3 });
  }
  async getAccountSubdomains(e3) {
    return te({ aptosConfig: this.config, ...e3 });
  }
  async getDomainSubdomains(e3) {
    return oe({ aptosConfig: this.config, ...e3 });
  }
};

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5L6SRCJP.mjs
var t12 = class {
  constructor(i48) {
    this.config = new i47(i48), this.account = new l10(this.config), this.ans = new A11(this.config), this.coin = new t11(this.config), this.digitalAsset = new D6(this.config), this.event = new s11(this.config), this.faucet = new r21(this.config), this.fungibleAsset = new r22(this.config), this.general = new u8(this.config), this.staking = new t3(this.config), this.transaction = new h11(this.config);
  }
};
function n22(m12, i48, A13) {
  Object.getOwnPropertyNames(i48.prototype).forEach((e3) => {
    let o13 = Object.getOwnPropertyDescriptor(i48.prototype, e3);
    o13 && (o13.value = function(...d9) {
      return this[A13][e3](...d9);
    }, Object.defineProperty(m12.prototype, e3, o13));
  });
}
n22(t12, l10, "account");
n22(t12, A11, "ans");
n22(t12, t11, "coin");
n22(t12, D6, "digitalAsset");
n22(t12, s11, "event");
n22(t12, r21, "faucet");
n22(t12, r22, "fungibleAsset");
n22(t12, u8, "general");
n22(t12, t3, "staking");
n22(t12, h11, "transaction");

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ALFESCPU.mjs
var p11 = ((i48) => (i48.JSON = "application/json", i48.BCS = "application/x-bcs", i48.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", i48))(p11 || {});
var a12 = ((t13) => (t13[t13.Bool = 0] = "Bool", t13[t13.U8 = 1] = "U8", t13[t13.U64 = 2] = "U64", t13[t13.U128 = 3] = "U128", t13[t13.Address = 4] = "Address", t13[t13.Signer = 5] = "Signer", t13[t13.Vector = 6] = "Vector", t13[t13.Struct = 7] = "Struct", t13[t13.U16 = 8] = "U16", t13[t13.U32 = 9] = "U32", t13[t13.U256 = 10] = "U256", t13[t13.Reference = 254] = "Reference", t13[t13.Generic = 255] = "Generic", t13))(a12 || {});
var g8 = ((o13) => (o13[o13.U8 = 0] = "U8", o13[o13.U64 = 1] = "U64", o13[o13.U128 = 2] = "U128", o13[o13.Address = 3] = "Address", o13[o13.U8Vector = 4] = "U8Vector", o13[o13.Bool = 5] = "Bool", o13[o13.U16 = 6] = "U16", o13[o13.U32 = 7] = "U32", o13[o13.U256 = 8] = "U256", o13))(g8 || {});
var y9 = ((i48) => (i48[i48.Script = 0] = "Script", i48[i48.EntryFunction = 2] = "EntryFunction", i48[i48.Multisig = 3] = "Multisig", i48))(y9 || {});
var u9 = ((r23) => (r23[r23.MultiAgentTransaction = 0] = "MultiAgentTransaction", r23[r23.FeePayerTransaction = 1] = "FeePayerTransaction", r23))(u9 || {});
var d8 = ((e3) => (e3[e3.Ed25519 = 0] = "Ed25519", e3[e3.MultiEd25519 = 1] = "MultiEd25519", e3[e3.MultiAgent = 2] = "MultiAgent", e3[e3.FeePayer = 3] = "FeePayer", e3[e3.SingleSender = 4] = "SingleSender", e3))(d8 || {});
var c13 = ((n24) => (n24[n24.Ed25519 = 0] = "Ed25519", n24[n24.MultiEd25519 = 1] = "MultiEd25519", n24[n24.SingleKey = 2] = "SingleKey", n24[n24.MultiKey = 3] = "MultiKey", n24))(c13 || {});
var l11 = ((r23) => (r23[r23.Ed25519 = 0] = "Ed25519", r23[r23.Secp256k1 = 1] = "Secp256k1", r23))(l11 || {});
var _4 = ((r23) => (r23[r23.Ed25519 = 0] = "Ed25519", r23[r23.Secp256k1 = 1] = "Secp256k1", r23))(_4 || {});
var x7 = ((e3) => (e3.Pending = "pending_transaction", e3.User = "user_transaction", e3.Genesis = "genesis_transaction", e3.BlockMetadata = "block_metadata_transaction", e3.StateCheckpoint = "state_checkpoint_transaction", e3))(x7 || {});
function b8(s12) {
  return s12.type === "pending_transaction";
}
function k2(s12) {
  return s12.type === "user_transaction";
}
function f12(s12) {
  return s12.type === "genesis_transaction";
}
function E5(s12) {
  return s12.type === "block_metadata_transaction";
}
function C5(s12) {
  return s12.type === "state_checkpoint_transaction";
}
function U10(s12) {
  return "signature" in s12 && s12.signature === "ed25519_signature";
}
function T9(s12) {
  return "signature" in s12 && s12.signature === "secp256k1_ecdsa_signature";
}
function A12(s12) {
  return s12.type === "multi_agent_signature";
}
function W4(s12) {
  return s12.type === "fee_payer_signature";
}
function P5(s12) {
  return s12.type === "multi_ed25519_signature";
}
var v8 = ((i48) => (i48.PRIVATE = "private", i48.PUBLIC = "public", i48.FRIEND = "friend", i48))(v8 || {});
var M5 = ((n24) => (n24.STORE = "store", n24.DROP = "drop", n24.KEY = "key", n24.COPY = "copy", n24))(M5 || {});
var h13 = ((r23) => (r23.VALIDATOR = "validator", r23.FULL_NODE = "full_node", r23))(h13 || {});
var m11 = ((n24) => (n24[n24.Ed25519 = 0] = "Ed25519", n24[n24.MultiEd25519 = 1] = "MultiEd25519", n24[n24.SingleKey = 2] = "SingleKey", n24[n24.MultiKey = 3] = "MultiKey", n24))(m11 || {});
var R3 = ((r23) => (r23[r23.Ed25519 = 0] = "Ed25519", r23[r23.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", r23))(R3 || {});
var S7 = ((e3) => (e3[e3.DeriveAuid = 251] = "DeriveAuid", e3[e3.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", e3[e3.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", e3[e3.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", e3[e3.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", e3))(S7 || {});

// node_modules/.pnpm/@aptos-labs+ts-sdk@1.7.0/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6IFMQ5AS.mjs
var n23 = class {
  constructor(e3) {
    this.buffer = new ArrayBuffer(e3.length), new Uint8Array(this.buffer).set(e3, 0), this.offset = 0;
  }
  read(e3) {
    if (this.offset + e3 > this.buffer.byteLength)
      throw new Error("Reached to the end of buffer");
    let i48 = this.buffer.slice(this.offset, this.offset + e3);
    return this.offset += e3, i48;
  }
  deserializeStr() {
    let e3 = this.deserializeBytes();
    return new TextDecoder().decode(e3);
  }
  deserializeBytes() {
    let e3 = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(e3));
  }
  deserializeFixedBytes(e3) {
    return new Uint8Array(this.read(e3));
  }
  deserializeBool() {
    let e3 = new Uint8Array(this.read(1))[0];
    if (e3 !== 1 && e3 !== 0)
      throw new Error("Invalid boolean value");
    return e3 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    let e3 = this.deserializeU32(), i48 = this.deserializeU32();
    return BigInt(BigInt(i48) << BigInt(32) | BigInt(e3));
  }
  deserializeU128() {
    let e3 = this.deserializeU64(), i48 = this.deserializeU64();
    return BigInt(i48 << BigInt(64) | e3);
  }
  deserializeU256() {
    let e3 = this.deserializeU128(), i48 = this.deserializeU128();
    return BigInt(i48 << BigInt(128) | e3);
  }
  deserializeUleb128AsU32() {
    let e3 = BigInt(0), i48 = 0;
    for (; e3 < U; ) {
      let r23 = this.deserializeU8();
      if (e3 |= BigInt(r23 & 127) << BigInt(i48), !(r23 & 128))
        break;
      i48 += 7;
    }
    if (e3 > U)
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(e3);
  }
  deserialize(e3) {
    return e3.deserialize(this);
  }
  deserializeVector(e3) {
    let i48 = this.deserializeUleb128AsU32(), r23 = new Array();
    for (let s12 = 0; s12 < i48; s12 += 1)
      r23.push(this.deserialize(e3));
    return r23;
  }
};

export {
  require_nacl_fast,
  bytesToHex,
  hexToBytes,
  hmac,
  pbkdf2,
  sha256,
  sha512,
  sha3_256,
  aptosClient,
  s,
  l,
  i,
  B,
  n3 as n,
  A,
  g,
  w,
  h2 as h,
  c,
  s3 as s2,
  c3 as c2,
  T2 as T,
  p2 as p,
  g3 as g2,
  f2 as f,
  s4 as s3,
  A3 as A2,
  f3 as f2,
  x,
  S,
  n5 as n2,
  o4 as o,
  N,
  T4 as T2,
  A6 as A3,
  a2 as a,
  r3 as r,
  t2 as t,
  r5 as r2,
  t5 as t2,
  c4 as c3,
  u2 as u,
  d2 as d,
  g4 as g3,
  p5 as p2,
  z,
  T6 as T3,
  S2,
  U2 as U,
  f6 as f3,
  h5 as h2,
  y2 as y,
  b2 as b,
  o5 as o2,
  E,
  V,
  j2 as j,
  G3 as G,
  S3,
  r6 as r3,
  Z,
  U3 as U2,
  p6 as p3,
  b3 as b2,
  y3 as y2,
  m6 as m,
  B2,
  v3 as v,
  t6 as t3,
  a3 as a2,
  f7 as f4,
  t7 as t4,
  M,
  D2 as D,
  N4 as N2,
  P,
  w4 as w2,
  G4 as G2,
  A7 as A4,
  T7 as T4,
  E2,
  d3 as d2,
  x3 as x2,
  S4,
  B3,
  U4 as U3,
  I,
  b4 as b3,
  $3 as $,
  R,
  W,
  L2 as L,
  a5 as a3,
  i27 as i2,
  e,
  d4 as d3,
  m7 as m2,
  y4 as y3,
  g5 as g4,
  D3 as D2,
  E3,
  A8 as A5,
  f8 as f5,
  U5 as U4,
  h6 as h3,
  l5 as l2,
  v4 as v2,
  d5 as d4,
  g6 as g5,
  p7 as p4,
  u3 as u2,
  S5,
  c5 as c4,
  c6 as c5,
  p8 as p5,
  h8 as h4,
  g7 as g6,
  Z2,
  P3 as P2,
  a7 as a4,
  U6 as U5,
  s5 as s4,
  n16 as n3,
  a8 as a5,
  u4 as u3,
  l6 as l3,
  c7 as c6,
  c8 as c7,
  d6 as d5,
  u5 as u4,
  l7 as l4,
  A9 as A6,
  y5 as y4,
  o7 as o3,
  t10 as t5,
  D4 as D3,
  a9 as a6,
  A10 as A7,
  z2,
  h9 as h5,
  l9 as l5,
  U7 as U6,
  f10 as f6,
  b5 as b4,
  r18 as r4,
  o8 as o4,
  c9 as c8,
  p9 as p6,
  y6 as y5,
  n17 as n4,
  n18 as n5,
  o10 as o5,
  a11 as a7,
  e2,
  s10 as s5,
  r19 as r5,
  Wn,
  sn,
  un,
  $n,
  Cn,
  I3 as I2,
  Kn,
  kn,
  tn,
  dn,
  An,
  c10 as c9,
  r20 as r6,
  p10 as p7,
  T8 as T5,
  m9 as m3,
  i47 as i3,
  t12 as t6,
  p11 as p8,
  a12 as a8,
  g8 as g7,
  y9 as y6,
  u9 as u5,
  d8 as d6,
  c13 as c10,
  l11 as l6,
  _4 as _,
  x7 as x3,
  b8 as b5,
  k2 as k,
  f12 as f7,
  E5 as E4,
  C5 as C,
  U10 as U7,
  T9 as T6,
  A12 as A8,
  W4 as W2,
  P5 as P3,
  v8 as v3,
  M5 as M2,
  h13 as h6,
  m11 as m4,
  R3 as R2,
  S7 as S6,
  n23 as n6
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-SWUDZY6M.js.map
